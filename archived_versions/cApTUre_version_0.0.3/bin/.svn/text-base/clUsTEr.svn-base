#!/usr/bin/perl
use strict;
use warnings;
use IO::File;
use IO::Dir;
use FindBin;
use lib "$FindBin::Bin/../perl_libs";
use Config::Std;
use Getopt::Long;
use IPC::System::Simple qw (run capture);
use Parallel::ForkManager;

my $VERSION = '0.0.5';

my $usage = "
Description:
	
	clUsTEr: vAriant collecTing UGP pipeline version specialized for CHPC cluster environment : $VERSION

	clUsTEr is a PBS cluster pipeline written in Perl, modified from the 
	Utah Genome Project (UGP) cApTUrE pipeline to run in the CHPC cluster enviroment
	http://weatherby.genetics.utah.edu/UGP/wiki/index.php/Main_Page

	Currently it incorporates the following tools:
		-FastQC
		-bwa
		-samtools
		-Picard
		-GATK

	clUsTEr requires a config file given as the first commandline argument.
	And all instruction and requirement are given therein.

Required options:
	-rf,  --region_file : Region file used by GATK UG.
	-cfg, --config      : clUsTEr config file.

Options:
	-c, --clean	    : Removes all list, pbs, and report files.
	-h, --help	    : Displays this usage statement.

\n";

my ( $clean, $help, $region, $config);
GetOptions(
    "clean|c"          => \$clean,
    "help|h"           => \$help,
    "region_file|rf=s" => \$region,
    "config|cfg=s"     => \$config,
);
die $usage if $help;

# capture clean
if ($clean) {
    system("rm -f *list *pbs* *.report qsub_*");
    die "Cleaning up list and report files.\n";
}

my $conf_file = $config or die $usage;

# tracker for repeted_runs
my $times = '0';

# read the config file.
read_config $conf_file => my %config;

## file variables
my $req    = $config{'required'};
my $soft   = $config{'software'};

# parallel process manager
my $pm = Parallel::ForkManager->new( $req->{'cpu'} );

# hash of all step of pipeline for PBS.
my %cmd_list;

run_clUsTEr();


#-------------------------------------------------------------------------------
#                                   SUBS
#-------------------------------------------------------------------------------

sub run_clUsTEr {

    # dispatch table
    my $steps = {
        indexer                => \&indexer,
        fastqc                 => \&fastqc,
        bwa_mem                => \&bwa_mem,
        bwa_aln                => \&bwa_aln,
        bwa_sampe              => \&bwa_sampe,
        SortSam                => \&SortSam,
        idxstats               => \&idxstats,
        flagstat               => \&flagstat,
        MergeSamFiles          => \&MergeSamFiles,
        MarkDuplicates         => \&MarkDuplicates,
        RealignerTargetCreator => \&RealignerTargetCreator,
        IndelRealigner         => \&IndelRealigner,
        BaseRecalibrator       => \&BaseRecalibrator,
        PrintReads             => \&PrintReads,
        CollectMultipleMetrics => \&CollectMultipleMetrics,
        LeftAlignIndels        => \&LeftAlignIndels,
        ReduceReads            => \&ReduceReads,
        SNP                    => \&SNP,
        INDEL                  => \&INDEL,
	VariantPrepare	=> \&VariantPrepare,
    };

    # Run verify and each step of order list
    config_verify();
    foreach my $tool ( @{ $config{'order'}{'command_order'} } ) {
        $steps->{$tool}->();
    }
    PBS_annotate();
}

#-------------------------------------------------------------------------------

sub open_dir {
    my $dir = shift;
    my $DH  = IO::Dir->new($dir)
      or die_messenger("Could not open directory $dir.");
    return \$DH;
}

#-------------------------------------------------------------------------------

sub open_list {
    my $file = shift;
    my @list = `cat $file`;
    return \@list;
}

#-------------------------------------------------------------------------------

sub config_verify {

    # Check versions
    if ( $VERSION ne $req->{'ugp_version'} ) {
        die_messenger( "Software version: $VERSION and requested version: "
              . "$req->{'ugp_version'} do not match." );
    }

    # check that fastq dir hash trailing slash
    # as well as software paths.
    unless ( $req->{'fastq_dir'} =~ /\/$/ ) {
        $req->{'fastq_dir'} =~ s/$/\//;
    }

    foreach my $prog ( keys %{$soft} ) {
        unless ( $soft->{$prog} =~ /\/$/ ) {
            $soft->{$prog} =~ s/$/\//;
        }
    }

    # check for reference fasta.
    if ( !-e $req->{'fasta'} ) {
        die_messenger("Fasta file not found");
    }

    unless ( $config{'required'}{'known_indel'} ) {
        die_messenger(
            "Cant find known_indel file[s] for RealignerTargetCreator.");
    }

    if ( $req->{'unified_bg_bams'} ) {
        my $BKB = IO::File->new( 'background_bam.list', 'w' );
        my $bams = `find $req->{'unified_bg_bams'} -name "*reduced.bam"`;
        ($bams)
          ? print $BKB $bams
          : die_messenger("Cant find unified_bg_bams reduced bam file[s]");
        $BKB->close;
    }
}

#-------------------------------------------------------------------------------

sub file_verify {
    my @files = @_;

    my @file_list;
    foreach my $list (@files) {
        unless ( -e $list and -s $list ) {
            die_messenger("Can't find required $list file ");
        }
    }
}

#-------------------------------------------------------------------------------

sub die_messenger {
    my $message = shift;

    open( STDERR, ">>", 'Fatal_error.log' );

    print "Error occured $message\n";
    my $error = "FATAL: $message --";
    die $error;
}

#-------------------------------------------------------------------------------

sub options {
    my ( $call, $flag ) = @_;
    my $section = $config{$call};

    my $opts;
    foreach my $options ( keys %{$section} ) {
        next unless ( $section->{$options} );
        if ( $section->{$options} eq 'TRUE' ) {
            $opts .= "$flag$options ";
        }
        elsif ( ref $section->{$options} eq 'ARRAY' ) {
            foreach my $known ( @{ $section->{$options} } ) {
                $opts .= "$flag$options $known ";
            }
        }
        elsif ( $section->{$options} ) {
            $opts .= "$flag$options $section->{$options} ";
        }
    }
    return $opts;
}

#-------------------------------------------------------------------------------

sub name_parse {
    my $path = shift;

    my @schema = split /\_/, $path;
    return @schema;
}

#-------------------------------------------------------------------------------

sub indexer {
	bwa_index();
	gatk_index();
	return;
}

#-------------------------------------------------------------------------------
# still need to add to this sub.

sub md5sum {
    my $FQDIR = open_dir( $req->{'fastq_dir'} );

    foreach my $fq ( $$FQDIR->read ) {
        next unless ( $fq =~ /\.(fastq.gz|fq.gz)$/ );

        ( my $md = $fq ) =~ s/\.(fastq.gz|fq.gz)$/\.md5/;
        my $cmd = "md5sum $fq > $md";
        cmd_log($cmd);
        runner($cmd);
    }
    $$FQDIR->close;

    # Now collect the md5 files.
    my $MDDIR = open_dir( $req->{'md5'} );

    foreach my $md5 ( $MDDIR->read ) {
        next unless ( $md5 =~ /\.md5$/ );
        ### check to file to each other useing diff.
    }

    end_log('md5sum');
}

#-------------------------------------------------------------------------------
###### fastqc ######

sub fastqc {
    my $opts = options( 'fastqc', '--' ) || '';
    my $FQDIR = open_dir( $req->{'fastq_dir'} );

    # make a fastq directory
    my $output_dir = "$req->{'fastq_dir'}fastqc";
    `mkdir $output_dir`;

    foreach my $file ( $$FQDIR->read ) {
        next unless ( $file =~ /\.gz$/ );

        my $input = "$req->{'fastq_dir'}$file";
        my $output;
        if ( $file =~ /\.gz/ ) {
            ( $output = $input ) =~ s/.gz$//;
        }
        else { $output = $input; }

        my @p_file = name_parse($file);

        #fastqc needs files to be unzipped.
        unless ( -e $output ) {
            my $gun = "gunzip -c $input > $output";
            push @{ $cmd_list{ $p_file[0] } }, $gun;
        }

        system("touch $output $output_dir");
        my $cmd = "$soft->{'fastqc'}fastqc $opts -o $output_dir -f fastq $output 2>> fastQC.report";
        push @{ $cmd_list{ $p_file[0] } }, $cmd;
    }
    $$FQDIR->close;
}

#-------------------------------------------------------------------------------
###### BWA ######

sub bwa_index {
    my $opts = options( 'bwa_index', '-' ) || '';
    my $cmd = "$soft->{'bwa'}bwa index $opts $req->{'fasta'} 2>> bwa_index.report";

    push @{ $cmd_list{'index'} }, $cmd;
}

#-------------------------------------------------------------------------------

sub bwa_mem {
    my $opts = options( 'bwa_mem', '-' ) || '';
    my $FQDIR = open_dir( $req->{'fastq_dir'} );

    my @fq_files;
    foreach my $i ( $$FQDIR->read ) {
        chomp $i;
        next if ( $i !~ /.gz$/ );

        push @fq_files, $i;
    }
    my @sorted_fqs = sort { $a cmp $b } @fq_files;

    my %fq_hash;
    foreach my $f (@sorted_fqs) {
        chomp $f;

        my @parts = split "_", $f;
        push @{ $fq_hash{ $parts[0] } }, $f;
    }

    my $id = '1';
    my @mem_cmds;
    for ( my $i = 0 ; $i < scalar @fq_files ; $i += 2 ) {

        foreach my $g ( keys %fq_hash ) {

            my $fq1 = $fq_hash{$g}[$i];
            my $fq2 = $fq_hash{$g}[ $i + 1 ];
            next unless ( $fq1 && $fq2 );

            # paths
            my $fq1_path = "$req->{'fastq_dir'}$fq1";
            my $fq2_path = "$req->{'fastq_dir'}$fq2";
            my $reads    = "$fq1_path $fq2_path";

            #take the first file which will work
            my @p_file = name_parse($fq1);

            # create ordered bam files.
            ( my $bam_name = $fq1 ) =~ s/(.*)\.(.*)\.gz/$1.bam/;
            my $bam_file = "$req->{'fastq_dir'}$bam_name";

            system("touch $bam_file");

            my $r_group = '\'@RG'
              . "\\tID:$id\\tSM:$p_file[0]\\tPL:ILLUMINA\\tLB:$p_file[0]\'";

            my $cmd =
                "$soft->{'bwa'}bwa mem -M -R $r_group $opts $req->{'fasta'} "
              . "$reads 2>> bwa_mem.report | $soft->{'samtools'}samtools view "
              . "-bSho $bam_file - 2>> samtools_bam.report";

            push @{ $cmd_list{ $p_file[0] } }, $cmd;
            $id++;
        }
    }
    $$FQDIR->close;
}

#-------------------------------------------------------------------------------

sub bwa_aln {
    my $opts = options( 'bwa_aln', '-' ) || '';
    my $FQDIR = open_dir( $req->{'fastq_dir'} );

    foreach my $file ( $$FQDIR->read ) {
        next unless ( $file =~ /\.gz/ );

        my @p_file = name_parse($file);

        ( my $sai_name = $file ) =~ s/(.*)\.(.*)\.gz/$1.sai/;
        my $sai_file = "$req->{'fastq_dir'}$sai_name";

        system("touch $sai_file");

        my $cmd = "$soft->{'bwa'}bwa aln $opts $req->{'fasta'} "
          . "$req->{'fastq_dir'}$file > $sai_file 2>> bwa_aln.report";

        push @{ $cmd_list{ $p_file[0] } }, $cmd;
    }
    $$FQDIR->close;
    return;
}

#-------------------------------------------------------------------------------

sub PBS_annotate {

    my @pbs;
    foreach my $set ( keys %cmd_list ) {
        my $FH = IO::File->new( "$set.pbs", 'a+' ) or die;
        push @pbs, "$set.pbs";

        print $FH "
#PBS -S /bin/bash
#PBS -l nodes=1:ppn=12,walltime=24:00:00
#PBS -A yandell-em
#PBS -M shawn.rynearson\@gmail.com	
source /uufs/chpc.utah.edu/common/home/u0413537/.bash_profile
date
cd /uufs/chpc.utah.edu/common/home/u0413537/Yandell-scratch/cApTUrE/bin
\n";
        foreach my $group ( @{ $cmd_list{$set} } ) {
            print $FH $group, "\n";
        }
        print $FH "date";
        $FH->close;
    }

    foreach my $qsub (@pbs) {
	next unless $qsub =~ /index_*/;
        print "qsub $qsub &>> qsub_index\n";
        system "qsub $qsub &>> qsub_index";
    }

    foreach my $qsub (@pbs) {
        next if $qsub =~ /Unified_*|Variant_recal_*|Merge_*|Applyed_*|index_*|SelectVariants_*|CombineVariants/;

        my @jobs = `cat qsub_index`;

        my @before;
        foreach my $i (@jobs) {
            chomp $i;
            push @before, $i;
        }
        my $wait = join( ":", @before );
        print "qsub -W depend=afterok:$wait $qsub\n";
        system "qsub -W depend=afterok:$wait $qsub &>> qsub_align";
    }

    foreach my $qsub (@pbs) {
        next unless $qsub =~ /Unified_*/;
        my @jobs = `cat qsub_align`;

        my @before;
        foreach my $i (@jobs) {
            chomp $i;
            push @before, $i;
        }
        my $wait = join( ":", @before );
        print "qsub -W depend=afterok:$wait $qsub\n";
        system "qsub -W depend=afterok:$wait $qsub &>> qsub_unified";
    }

    foreach my $qsub (@pbs) {
        next unless $qsub =~ /Merge*/;
        my @jobs = `cat qsub_unified`;
	my @before;
        foreach my $i (@jobs) {
            chomp $i;
            push @before, $i;
        }
        my $wait = join( ":", @before );
        print "qsub -W depend=afterok:$wait $qsub\n";
       system "qsub -W depend=afterok:$wait $qsub &>> qsub_merged";
    }

    foreach my $qsub (@pbs) {
        next unless $qsub =~ /Variant_recal*/;
        my @jobs = `cat qsub_merged`;
        my @before;
        foreach my $i (@jobs) {
            chomp $i;
            push @before, $i;
        }
        my $wait = join( ":", @before );
        print "qsub -W depend=afterok:$wait $qsub\n";
        system "qsub -W depend=afterok:$wait $qsub &>> qsub_recal";
    }

    foreach my $qsub (@pbs) {
        next unless $qsub =~ /Applyed*/;
        my @jobs = `cat qsub_recal`;
        my @before;
        foreach my $i (@jobs) {
            chomp $i;
            push @before, $i;
        }
        my $wait = join( ":", @before );
        print "qsub -W depend=afterok:$wait $qsub\n";
        system "qsub -W depend=afterok:$wait $qsub &>> qsub_applyed";
    }

    foreach my $qsub (@pbs) {
        next unless $qsub =~ /SelectVariants_*/;
        my @jobs = `cat qsub_applyed`;
        my @before;
        foreach my $i (@jobs) {
            chomp $i;
            push @before, $i;
        }
        my $wait = join( ":", @before );
        print "qsub -W depend=afterok:$wait $qsub\n";
        system "qsub -W depend=afterok:$wait $qsub &>> qsub_select_variants";
    }

    foreach my $qsub (@pbs) {
        next unless $qsub =~ /CombineVariants*/;
        my @jobs = `cat qsub_select_variants`;
        my @before;
        foreach my $i (@jobs) {
            chomp $i;
            push @before, $i;
        }
        my $wait = join( ":", @before );
        print "qsub -W depend=afterok:$wait $qsub\n";
        system "qsub -W depend=afterok:$wait $qsub &>> qsub_combine_variants";
    }

    return;
}

#-------------------------------------------------------------------------------

sub bwa_sampe {

    my $opts = options( 'bwa_sampe', '-' ) || '';
    my $DH = open_dir( $req->{'fastq_dir'} );

    my ( @sai, @fq );
    foreach my $file ( $$DH->read ) {
        next unless ( $file =~ /(gz||sai)$/ );
        if ( $file =~ /sai$/ ) {
            push @sai, $file;
        }
        elsif ( $file =~ /.gz$/ ) {
            push @fq, $file;
        }
    }
    my @sort_fq  = sort { $a cmp $b } @fq;
    my @sort_sai = sort { $a cmp $b } @sai;

    # check that the sai files are even.
    if ( scalar @sort_sai % 2 ) {
        die_messenger(
            "sai file looks inconsistent, must only have two per fastq file.");
    }

    my $id = '1';
    while (@sort_fq) {

        my @sq = splice( @sort_fq,  0, 2 );
        my @ss = splice( @sort_sai, 0, 2 );

        # update with path information.
        my @sa  = map { "$req->{'fastq_dir'}$_" } @ss;
        my @sfq = map { "$req->{'fastq_dir'}$_" } @sq;

        my @p_file = name_parse( $ss[0] );

        # create ordered bam files.
        ( my $bam_name = $sq[0] ) =~ s/(.*)\.(.*)\.gz/$1.bam/;
        my $bam_file = "$req->{'fastq_dir'}$bam_name";

        my $r_group =
          '\'@RG' . "\\tID:$id\\tSM:$p_file[0]\\tPL:ILLUMINA\\tLB:$p_file[0]\'";

        # touch output file for downstream cmds.
        system("touch $bam_file");

        my $cmd =
	    "$soft->{'bwa'}bwa sampe -r $r_group $opts $req->{'fasta'} $sa[0] $sa[1] "
          . "$sfq[0] $sfq[1] | $soft->{'samtools'}samtools view -bSho $bam_file - &>> bwa_sampe.report";

        push @{ $cmd_list{ $p_file[0] } }, $cmd;
        $id++;
    }
    $$DH->close;
}

#-------------------------------------------------------------------------------
###### Picard and Samtools ######

sub SortSam {
    my $DIR = open_dir( $req->{'fastq_dir'} );
    my $SORTLIST = IO::File->new( 'sorted_bam.list', 'w' );

    # get and order
    my $opts = options( 'SortSam', '=' ) || '';
    $opts =~ s/\=(\S+) /$1=/g;

    foreach my $bam ( $$DIR->read ) {
        next unless ( $bam =~ /\.bam$/ );
        next if ( $bam =~ /\_sorted.bam/ );

        my @p_file = name_parse($bam);

        # fasta dir
        my $dir = $req->{'fastq_dir'};
        ( my $sort_file = $bam ) =~ s/\.bam$/\_sorted.bam/;

        # touch output file for downstream cmds.
        system("touch $dir$sort_file");

        my $cmd =
            "java -jar -XX:ParallelGCThreads=$req->{'picard_java_threads'} "
          . "-Xmx$req->{'picard_java_Xmx'}g -Djava.io.tmpdir=$req->{'java_tmp'} "
          . "$soft->{'picard'}SortSam.jar INPUT=$dir$bam OUTPUT=$dir$sort_file "
          . "$opts &>> SortSam.report";

        push @{ $cmd_list{ $p_file[0] } }, $cmd;
        print $SORTLIST "$dir$sort_file\n";
    }
    $$DIR->close;
    $SORTLIST->close;
}

#-------------------------------------------------------------------------------

sub idxstats {
    my $DIR = open_dir( $req->{'fastq_dir'} );

    foreach my $bam ( $$DIR->read ) {
        next unless ( $bam =~ /\_sorted.bam/ );
        ( my $idx_file = $bam ) =~ s/\.bam/\.stats/;

	my $output = "$req->{'fastq_dir'}$idx_file";
	system("touch $output");

        my $idx_cmd =
		"$soft->{'samtools'}samtools idxstats $req->{'fastq_dir'}$bam > $output 2>> idxstats.report";
    }
    $DIR->close;
}

#-------------------------------------------------------------------------------
### add flagstat reviewer

sub flagstat {
    my $DIR = open_dir( $req->{'fastq_dir'} );

    foreach my $bam ( $$DIR->read ) {
        next unless ( $bam =~ /\_sorted.bam$/ );

        my $dir = $req->{'fastq_dir'};
        ( my $flag_file = $bam ) =~ s/\.bam/.flagstat/;

        my @p_file = name_parse($bam);
        system("touch $dir$flag_file");

        my $cmd = "$soft->{'samtools'}samtools flagstat $dir$bam > $dir$flag_file 2>> flagstat.report";
        push @{ $cmd_list{ $p_file[0] } }, $cmd;
    }
    $$DIR->close;
}

#-------------------------------------------------------------------------------
###### Picard ######

sub MarkDuplicates {
    my $DDLIST = IO::File->new( 'dedup_bam.list', 'w' );

    # created this section because if working with just pairs MergeSamFile
    # could be unused, although it will not fail.
    my $list_file;
    ( -e 'merged_bam.list' and -s 'merged_bam.list' ) ? $list_file =
      'merged_bam.list'
      : ( -e 'sorted_bam.list' and -s 'sorted_bam.list' ) ? $list_file =
      'sorted_bam.list'
      : die_messenger("sorted_bam.list or merged_bam.list not found.");

    my $opened = open_list($list_file);

    my $opts = options( 'MarkDuplicates', '=' ) || '';
    $opts =~ s/\=(\S+) /$1=/g;

    my %dedup;
    foreach my $bam ( @{$opened} ) {
        chomp $bam;

        ( my $output = $bam ) =~ s/\.bam/_Dedup.bam/;
        ( my $metric = $bam ) =~ s/\.bam/_Dedup.metrics/;

        # split up the commandline to the needed group name
        my @f_name = split /\//, $bam;
        my @p_file = name_parse( $f_name[-1] );

        # create a new merge file of dedups.
        $dedup{$output} = '1';

        system("touch $output");

        my $cmd =
	    "java -Xmx$req->{'picard_java_Xmx'}g -XX:ParallelGCThreads=$req->{'picard_java_threads'} "
          . "-Djava.io.tmpdir=$req->{'java_tmp'} -jar "
          . "$soft->{'picard'}MarkDuplicates.jar INPUT=$bam OUTPUT=$output METRICS_FILE=$metric "
          . "$opts &>> MarkDuplicates.report";

        push @{ $cmd_list{ $p_file[0] } }, $cmd;
    }

    # print the dedup_bam.list file.
    map { print $DDLIST "$_\n" } keys %dedup;

    $DDLIST->close;
}

#-------------------------------------------------------------------------------

sub MergeSamFiles {

    # files will always have to be sorted, to use this function.
    file_verify('sorted_bam.list');
    my $opened = open_list('sorted_bam.list');

    my $BAMLIST = IO::File->new( 'merged_bam.list', 'a+' );

    # get and order
    my $opts = options( 'MergeSamFiles', '=' ) || '';
    $opts =~ s/\=(\S+) /$1=/g;

    my %merge;
    foreach my $file ( @{$opened} ) {
        chomp $file;
        $file =~ s/$req->{'fastq_dir'}//;
        my @p_file = name_parse($file);

        # p_file[0] is the individual
        push @{ $merge{ $p_file[0] } }, $file;
    }

  # Will return if were trying to merge single files, which we don't need to do.
    my $single;
    my @sam_list = map { @{ $merge{$_} } } keys %merge;
    if ( scalar @sam_list == scalar keys %merge ) {
        $single = 'yes';
    }
    if ($single) { return }

    my %merge_list;
    foreach my $bam ( keys %merge ) {
        my $input = join( ':', @{ $merge{$bam} } );

        my @p_file = name_parse($bam);

        # add the paths and input/output tags
        $input =~ s/^/INPUT=$req->{'fastq_dir'}/;
        $input =~ s/:/ INPUT=$req->{'fastq_dir'}/g;
        my $output = "$req->{'fastq_dir'}$bam" . "_merged.bam";

        # This is what creates the merged_bam.list hash for the religners
        my $merge_bam = "$req->{'fastq_dir'}$bam" . "_merged.bam";
        $merge_list{$merge_bam} = '1';

        system("touch $output");

        my $cmd =
	    "java -Xmx$req->{'picard_java_Xmx'}g -XX:ParallelGCThreads=$req->{'picard_java_threads'} "
          . "-Djava.io.tmpdir=$req->{'java_tmp'} -jar "
          . "$soft->{'picard'}MergeSamFiles.jar $opts $input OUTPUT=$output 2>> MergeSamFiles.report";

        push @{ $cmd_list{ $p_file[0] } }, $cmd;
    }

    # print the merge_bam_list file.
    map { print $BAMLIST "$_\n"; } keys %merge_list;

    $BAMLIST->close;
    return;
}

#-------------------------------------------------------------------------------

sub CollectMultipleMetrics {
    my $opts = options( 'CollectMultipleMetrics', '=' ) || '';
    $opts =~ s/\=(\S+) /$1=/g;

    file_verify('recal_bam.list');
    my $opened = open_list('recal_bam.list');

    foreach my $bam ( @{$opened} ) {
        chomp $bam;
        ( my $w_file = $bam ) =~ s/\.bam$/\.metrics/;

	system("touch $w_file");

        my $cmd =
	    "java -Xmx$req->{'picard_java_Xmx'}g -XX:ParallelGCThreads=$req->{'picard_java_threads'} "
          . "-Djava.io.tmpdir=$req->{'java_tmp'} -jar "
          . "$soft->{'picard'}CollectMultipleMetrics.jar INPUT=$bam $opts "
          . "REFERENCE_SEQUENCE=$req->{'fasta'} OUTPUT=$w_file 2>> CollectMultipleMetrics.report";

        my @f_name = split /\//, $bam;
        my @p_file = name_parse( $f_name[-1] );

        push @{ $cmd_list{ $p_file[0] } }, $cmd;
    }
    return;
}

#-------------------------------------------------------------------------------
###### GATK ######

sub gatk_index {

    # gatk required use, but is a picard tool
    my $picard = "$soft->{'picard'}CreateSequenceDictionary.jar";
    my $fasta  = "$req->{'fasta'}";
    my $output = "$req->{'fasta'}";

    $output =~ s/(.*)\.(fasta|fa)/$1.dict/;
    system("touch $output");
    my $picard_cmd = "java -jar $picard R=$fasta O=$output 2>> seq_dict.report";
    push @{ $cmd_list{'index'} }, $picard_cmd;

    # now run to prepare the fasta index file.
    my $samtools = "$soft->{'samtools'}samtools faidx";
    my $sam_cmd  = "$samtools $fasta";
    push @{ $cmd_list{'index'} }, $sam_cmd;
    return;
}

#-------------------------------------------------------------------------------

sub RealignerTargetCreator {
    my @knowns = @{ $config{'required'}{'known_indel'} };
    my $opts = options( 'RealignerTargetCreator', '--' ) || '';

    my $known_vcfs;
    foreach my $vcf (@knowns) {
        chomp $vcf;
        next unless ( $vcf =~ /\.vcf$/ );
        $known_vcfs .= "--known $vcf ";
    }

    file_verify('dedup_bam.list');
    my $opened = open_list('dedup_bam.list');

    my $id = 1;
    foreach my $bam ( @{$opened} ) {
        chomp $bam;
        my $output =
          "$req->{'fastq_dir'}$req->{'ugp_id'}_realign.intervals_$id";
        $id++;

        # split up the commandline to the needed group name
        my @f_name = split /\//, $bam;
        my @p_file = name_parse( $f_name[-1] );

        system("touch $output");

        my $cmd =
	    "java -Xmx$req->{'gatk_tc_Xmx'}g -jar -Djava.io.tmpdir=$req->{'java_tmp'} "
          . "$soft->{'gatk'}GenomeAnalysisTK.jar -T RealignerTargetCreator -R $req->{'fasta'} -I $bam $opts "
          . "$known_vcfs -o $output &>> RealignerTargetCreator.report";

        my $cat_cmd = "cat $output >> $req->{'fastq_dir'}$req->{'ugp_id'}_realign.intervals";
        push @{ $cmd_list{ $p_file[0] } }, $cmd, $cat_cmd;
    }
    return;
}

#-------------------------------------------------------------------------------

sub IndelRealigner {
    my $INDEL_LIST = IO::File->new( 'realign_bam.list', 'w' );
    my $opts   = options( 'IndelRealigner', '--' ) || '';
    my $target = "$req->{'fastq_dir'}$req->{'ugp_id'}_realign.intervals";
    my @knowns = @{ $config{'required'}{'known_indel'} };

    my $known_vcfs;
    foreach my $vcf (@knowns) {
        chomp $vcf;
        next unless ( $vcf =~ /\.vcf$/ );
        $known_vcfs .= "--knownAlleles $vcf ";
    }
    file_verify('dedup_bam.list');
    my $opened = open_list('dedup_bam.list');

    my %indel_list;
    foreach my $dedup ( @{$opened} ) {
        chomp $dedup;

        next unless ( $dedup =~ /\.bam$/ );
        ( my $output = $dedup ) =~ s/\.bam/_realign.bam/;

        $indel_list{$output} = '1';

        system("touch $output");
        my $cmd =
	    "java -Xmx$req->{'gatk_ir_Xmx'}g -jar -XX:ParallelGCThreads=$req->{'picard_java_threads'} "
          . "-Djava.io.tmpdir=$req->{'java_tmp'} $soft->{'gatk'}GenomeAnalysisTK.jar -T IndelRealigner -R $req->{'fasta'} "
          . " -I $dedup $opts -targetIntervals $target $known_vcfs -o $output &>> IndelRealigner.report";

        my @f_name = split /\//, $dedup;
        my @p_file = name_parse( $f_name[-1] );

        push @{ $cmd_list{ $p_file[0] } }, $cmd;
    }

    # create the list file.
    map { print $INDEL_LIST "$_\n" } keys %indel_list;
    $INDEL_LIST->close;

    return;
}

#-------------------------------------------------------------------------------

sub ReduceReads {
    my $opts = options( 'ReduceReads', '--' ) || '';
    my $RD_LIST = IO::File->new( 'reduced_bam.list', 'w' );

    file_verify('recal_bam.list');
    my $opened = open_list('recal_bam.list');

    my %reduced;
    foreach my $bam ( @{$opened} ) {
        chomp $bam;
        ( my $output = $bam ) =~ s/\.bam$/_reduced.bam/;

        $reduced{$output} = '1';

	system("touch $output");
        my $cmd =
	    "java -Xmx$req->{'gatk_rr_Xmx'}g -jar -Djava.io.tmpdir=$req->{'java_tmp'} "
          . "-XX:ParallelGCThreads=$req->{'picard_java_threads'} $soft->{'gatk'}GenomeAnalysisTK.jar "
          . "-T ReduceReads -R $req->{'fasta'} -I $bam $opts "
          . "-o $output &>> ReduceReads.report";

        my @f_name = split /\//, $bam;
        my @p_file = name_parse( $f_name[-1] );

        push @{ $cmd_list{ $p_file[0] } }, $cmd;
    }

    # create the list file.
    map { print $RD_LIST $_, "\n" } keys %reduced;
    $RD_LIST->close;
    return;
}

#-------------------------------------------------------------------------------

sub BaseRecalibrator {
    my $opts = options( 'BaseRecalibrator', '--' ) || '';

    file_verify('realign_bam.list');
    my $opened_bams = open_list('realign_bam.list');

    my @known_lists = @{ $config{'required'}{'known_indel'} };
    my $dbsnp       = $config{'required'}{'known_dbsnp'};
    push @known_lists, $dbsnp;

    my $known_vcfs;
    foreach my $vcf (@known_lists) {
        chomp $vcf;
        next unless ( $vcf =~ /\.vcf$/ );
        $known_vcfs .= "--knownSites $vcf ";
    }

    foreach my $bam ( @{$opened_bams} ) {
        chomp $bam;

        my @f_name = split /\//, $bam;
        my @p_file = name_parse( $f_name[-1] );

    	my $output = "$req->{'fastq_dir'}$req->{'ugp_id'}_recal_data.$p_file[0].table";
	system("touch $output");

        my $cmd =
	    "java -Xmx$req->{'gatk_br_Xmx'}g -jar -Djava.io.tmpdir=$req->{'java_tmp'} "
          . "$soft->{'gatk'}GenomeAnalysisTK.jar -T BaseRecalibrator -R $req->{'fasta'} -I $bam $opts "
          . "$known_vcfs -o $output &>> BaseRecalibrator.report";

        push @{ $cmd_list{ $p_file[0] } }, $cmd;
    }
    return;
}

#-------------------------------------------------------------------------------/

sub PrintReads {
    my $opts       = options( 'PrintReads', '--' ) || '';
    my $RECAL_LIST = IO::File->new( 'recal_bam.list', 'w' );

    file_verify('realign_bam.list');
    my $opened = open_list('realign_bam.list');

    my %recal;
    foreach my $bam ( @{$opened} ) {
        chomp $bam;

        my @f_name = split /\//, $bam;
        my @p_file = name_parse( $f_name[-1] );
    	my $bqsr   = "$req->{'fastq_dir'}$req->{'ugp_id'}_recal_data.$p_file[0].table";

        my ($output) = $bam =~ /(.*)\.bam/;
        $output =~ s/$/_recal.bam/;

        $recal{$output} = 1;

	system("touch $output");
        my $cmd =
	    "java -Xmx$req->{'gatk_pr_Xmx'}g -jar -Djava.io.tmpdir=$req->{'java_tmp'} "
          . "$soft->{'gatk'}GenomeAnalysisTK.jar -T PrintReads -R $req->{'fasta'} -I $bam $opts "
          . "-BQSR $bqsr -o $output &>> PrintReads.report";

        push @{ $cmd_list{ $p_file[0] } }, $cmd;
    }

    # create the list file.
    map { print $RECAL_LIST $_, "\n" } keys %recal;
    $RECAL_LIST->close;
    return;
}

#-------------------------------------------------------------------------------

sub SNP {
    my $unifed_snp   = UnifiedGenotyper_SNP();
    my $unifed_recal = VariantRecalibrator_SNP();
    my $appled_snp   = ApplyRecalibration_SNP();
    return;
}

#-------------------------------------------------------------------------------

sub INDEL {
    my $unifed_indel = UnifiedGenotyper_INDEL();
    my $unifed_recal = VariantRecalibrator_INDEL();
    my $appled_indel = ApplyRecalibration_INDEL();
    return;
}

#-------------------------------------------------------------------------------

sub UnifiedGenotyper_SNP {
    my $opts = options( 'UnifiedGenotyper_SNP', '--' ) || '';
    my $output = "$req->{'fastq_dir'}$req->{'ugp_id'}_raw_snp.vcf";

    my $opened = open_list('reduced_bam.list');

    my $background;
    if ( $req->{'unified_bg_bams'} ) {
        file_verify('background_bam.list');
        my $bams = open_list('background_bam.list');

        foreach my $backs ( @{$bams} ) {
            chomp $backs;
            $background .= "-I $backs ";
        }
    }

    my $input_bams;
    foreach my $bam ( @{$opened} ) {
        chomp $bam;
        $input_bams .= "-I $bam ";
    }

    my %regions;
    my $REGION = IO::File->new($region, 'r');

    foreach my $i (<$REGION>) {
        chomp $i;
        my @chrs = split /:/, $i;
        push @{ $regions{ $chrs[0] } }, $i;
    }

    foreach my $chr ( keys %regions ) {

        my $output_reg = "chr$chr" . "_region_file.list";
        my $INTERNAL = IO::File->new( $output_reg, 'w' );

        foreach my $list ( @{ $regions{$chr} } ) {
            print $INTERNAL "$list\n";
        }
    }

    my @test = `ls *region_file.list`;
    my @all_output;
    foreach my $reg_file (@test) {
        chomp $reg_file;

        my @in_file = split /\_/, $reg_file;

        my $count_output = $output . "_$in_file[0]";
        system("touch $count_output");

        my $cmd =
	    "java -Xmx$req->{'gatk_ug_Xmx'}g -jar -Djava.io.tmpdir=$req->{'java_tmp'} "
          . "$soft->{'gatk'}GenomeAnalysisTK.jar -T UnifiedGenotyper -R $req->{'fasta'} $input_bams $background "
          . "$opts --intervals $reg_file -o $count_output &>> UnifiedGenotyper_SNP.report";

        push @all_output, $count_output;

        my $pbs_name = "Unified_SNP_$in_file[0]";
        push @{ $cmd_list{$pbs_name} }, $cmd;
    }

    my $merge = join( " --variant ", @all_output );
    $merge =~ s/^/--variant /;

    my $merge_cmd =
	"java -Xmx$req->{'gatk_ug_Xmx'}g -jar -Djava.io.tmpdir=$req->{'java_tmp'} "
      . "$soft->{'gatk'}GenomeAnalysisTK.jar -T CombineVariants -R $req->{'fasta'} $merge "
      . "-o $output &>> merge_SNP.report";

    push @{ $cmd_list{'Merge_SNP'} }, $merge_cmd;

    return;
}

#-------------------------------------------------------------------------------

sub UnifiedGenotyper_INDEL {
    my $opts = options( 'UnifiedGenotyper_INDEL', '--' ) || '';
    my $output = "$req->{'fastq_dir'}$req->{'ugp_id'}_raw_indel.vcf";

    system("touch $output");

    my $opened = open_list('reduced_bam.list');

    my $background;
    if ( $req->{'unified_bg_bams'} ) {
        file_verify('background_bam.list');
        my $bams = open_list('background_bam.list');

        foreach my $backs ( @{$bams} ) {
            chomp $backs;
            $background .= "-I $backs ";
        }
    }

    my $input_bams;
    foreach my $bam ( @{$opened} ) {
        chomp $bam;
        $input_bams .= "-I $bam ";
    }

    my @test = `ls *region_file.list`;
    my @all_output;
    foreach my $reg_file (@test) {
        chomp $reg_file;

        my @in_file = split /\_/, $reg_file;

        my $count_output = $output . "_$in_file[0]";
        system("touch $count_output");

        my $cmd =
	    "java -Xmx$req->{'gatk_ug_Xmx'}g -jar -Djava.io.tmpdir=$req->{'java_tmp'} "
          . "$soft->{'gatk'}GenomeAnalysisTK.jar -T UnifiedGenotyper -R $req->{'fasta'} $input_bams $background "
          . "$opts --intervals $reg_file -o $count_output &>> UnifiedGenotyper_INDEL.report";

        push @all_output, $count_output;

        my $pbs_name = "Unified_INDEL_$in_file[0]";
        push @{ $cmd_list{$pbs_name} }, $cmd;
    }

    my $merge = join( " --variant ", @all_output );
    $merge =~ s/^/--variant /;

    my $merge_cmd =
	"java -Xmx$req->{'gatk_ug_Xmx'}g -jar -Djava.io.tmpdir=$req->{'java_tmp'} "
      . "$soft->{'gatk'}GenomeAnalysisTK.jar -T CombineVariants -R $req->{'fasta'} $merge "
      . "-o $output &>> merge_INDEL.report";

    push @{ $cmd_list{'Merge_INDEL'} }, $merge_cmd;

    return;
}

#-------------------------------------------------------------------------------

sub VariantRecalibrator_SNP {

    my $input = "$req->{'fastq_dir'}$req->{'ugp_id'}_raw_snp.vcf";

    my @vqsr;
    if ( ref $config{'required'}{'vqsr_snp_vcf'} eq 'ARRAY' ) {
        @vqsr = @{ $config{'required'}{'vqsr_snp_vcf'} };
    }
    else {
        push @vqsr, $config{'required'}{'vqsr_snp_vcf'};
    }

    my @snp_file;
    if ( ref $config{'VariantRecalibrator_SNP'}{'resource'} eq 'ARRAY' ) {
        @snp_file = @{ $config{'VariantRecalibrator_SNP'}{'resource'} };
    }
    else {
        push @snp_file, $config{'VariantRecalibrator_SNP'}{'resource'};
    }

    # shift in order the resource lines.
    my $resource_call;
    if (@vqsr) {
        while ( my $site = @vqsr ) {
            my $resource = shift @snp_file;
            my $file     = shift @vqsr;
            $resource_call .= "--resource:$resource $file ";
        }

        # remove the resource info from the config hash
        delete $config{'VariantRecalibrator_SNP'}{'resource'};
    }

    # now run options to get others
    my $opts = options( 'VariantRecalibrator_SNP', '--' ) || '';

    my $recalFile = "-recalFile $req->{'fastq_dir'}$req->{'ugp_id'}_snp_recal";
    my $tranchFile =
      "-tranchesFile $req->{'fastq_dir'}$req->{'ugp_id'}_snp_tranches";
    my $rscriptFile =
      "-rscriptFile $req->{'fastq_dir'}$req->{'ugp_id'}_snp_plots.R";

    # big ugly system call to make needed recal tranch and rscript files.
    system( 
	"touch $req->{'fastq_dir'}$req->{'ugp_id'}_snp_recal $req->{'fastq_dir'}$req->{'ugp_id'}_snp_tranches $req->{'fastq_dir'}$req->{'ugp_id'}_snp_plots.R"
    );

    my $cmd =
	"java -Xmx$req->{'gatk_pr_Xmx'}g -jar -Djava.io.tmpdir=$req->{'java_tmp'} "
      . "$soft->{'gatk'}GenomeAnalysisTK.jar -T VariantRecalibrator -R $req->{'fasta'} -input $input $resource_call "
      . "$opts $recalFile $tranchFile $rscriptFile -mode SNP &>> VariantRecalibrator_SNP.report";

    push @{ $cmd_list{'Variant_recal_SNP'} }, $cmd;
}

#-------------------------------------------------------------------------------

sub VariantRecalibrator_INDEL {
    my $input = "$req->{'fastq_dir'}$req->{'ugp_id'}_raw_indel.vcf";

    my @vqsr;
    if ( ref $config{'required'}{'vqsr_indel_vcf'} eq 'ARRAY' ) {
        @vqsr = @{ $config{'required'}{'vqsr_indel_vcf'} };
    }
    else {
        push @vqsr, $config{'required'}{'vqsr_indel_vcf'};
    }

    my @indel_file;
    if ( ref $config{'VariantRecalibrator_INDEL'}{'resource'} eq 'ARRAY' ) {
        @indel_file = @{ $config{'VariantRecalibrator_INDEL'}{'resource'} };
    }
    else {
        push @indel_file, $config{'VariantRecalibrator_INDEL'}{'resource'};
    }

    my $resource_call;
    if (@vqsr) {
        while ( my $site = @vqsr ) {
            my $resource = shift @indel_file;
            my $file     = shift @vqsr;
            $resource_call .= "--resource:$resource $file ";
        }

        # remove the resource info from the config hash
        delete $config{'VariantRecalibrator_INDEL'}{'resource'};
    }

    # now run options to get others
    my $opts = options( 'VariantRecalibrator_INDEL', '--' ) || '';

    my $recalFile =
      "-recalFile $req->{'fastq_dir'}$req->{'ugp_id'}_indel_recal";
    my $tranchFile =
      "-tranchesFile $req->{'fastq_dir'}$req->{'ugp_id'}_indel_tranches";
    my $rscriptFile =
      "-rscriptFile $req->{'fastq_dir'}$req->{'ugp_id'}_indel_plots.R";

    # big ugly system call to make needed recal tranch and rscript files.
    system(
	"touch $req->{'fastq_dir'}$req->{'ugp_id'}_indel_recal $req->{'fastq_dir'}$req->{'ugp_id'}_indel_tranches $req->{'fastq_dir'}$req->{'ugp_id'}_indel_plots.R"
    );

    my $cmd =
	"java -Xmx$req->{'gatk_pr_Xmx'}g -jar -Djava.io.tmpdir=$req->{'java_tmp'} "
      . "$soft->{'gatk'}GenomeAnalysisTK.jar -T VariantRecalibrator -R $req->{'fasta'} -input $input $resource_call "
      . "$opts $recalFile $tranchFile $rscriptFile -mode INDEL &>> VariantRecalibrator_INDEL.report";

    push @{ $cmd_list{'Variant_recal_INDEL'} }, $cmd;
    return;
}

#-------------------------------------------------------------------------------

sub ApplyRecalibration_SNP {
    my $recalFile  = "$req->{'fastq_dir'}$req->{'ugp_id'}_snp_recal";
    my $tranchFile = "$req->{'fastq_dir'}$req->{'ugp_id'}_snp_tranches";
    my $input      = "$req->{'fastq_dir'}$req->{'ugp_id'}_raw_snp.vcf";
    ( my $output = $input ) =~ s/_raw_snp.vcf/_applyed_filtered_SNP.vcf/;
    my $opts = options( 'ApplyRecalibration_SNP', '--' ) || '';

    system("touch $output");

    my $cmd =
	"java -Xmx$req->{'gatk_pr_Xmx'}g -jar -Djava.io.tmpdir=$req->{'java_tmp'} "
      . "$soft->{'gatk'}GenomeAnalysisTK.jar -T ApplyRecalibration -R $req->{'fasta'} -input $input "
      . "$opts -recalFile  $recalFile -tranchesFile $tranchFile -mode SNP -o $output &>> ApplyRecalibration_SNP.report";

    ###return $cmd;
    push @{ $cmd_list{'Applyed_SNP'} }, $cmd;
}

#-------------------------------------------------------------------------------

sub ApplyRecalibration_INDEL {
    my $recalFile  = "$req->{'fastq_dir'}$req->{'ugp_id'}_indel_recal";
    my $tranchFile = "$req->{'fastq_dir'}$req->{'ugp_id'}_indel_tranches";
    my $input      = "$req->{'fastq_dir'}$req->{'ugp_id'}_raw_indel.vcf";
    ( my $output = $input ) =~ s/_raw_indel.vcf/_applyed_filtered_INDEL.vcf/;
    my $opts = options( 'ApplyRecalibration_INDEL', '--' ) || '';

    system("touch $output");

    my $cmd =
	"java -Xmx$req->{'gatk_pr_Xmx'}g -jar -Djava.io.tmpdir=$req->{'java_tmp'} "
      . "$soft->{'gatk'}GenomeAnalysisTK.jar -T ApplyRecalibration -R $req->{'fasta'} -input $input "
      . "$opts -recalFile  $recalFile -tranchesFile $tranchFile -mode INDEL -o $output &>> ApplyRecalibration_INDEL.report";

    push @{ $cmd_list{'Applyed_INDEL'} }, $cmd;
}

#-------------------------------------------------------------------------------

sub VariantPrepare {

    file_verify('reduced_bam.list');
    my $opened = open_list('reduced_bam.list');

    # collect column names
    my $sn;
    foreach my $bam ( @{$opened} ) {
        chomp $bam;
        my @path = split( "\/", $bam );
        my @f_name = name_parse( $path[-1] );
        $sn .= "-sn $f_name[0] ";
    }

    # Input and output and options
    my $snp_variant =
      "$req->{'fastq_dir'}$req->{'ugp_id'}_applyed_filtered_SNP.vcf";
    my $indel_variant =
      "$req->{'fastq_dir'}$req->{'ugp_id'}_applyed_filtered_INDEL.vcf";
    my $final_variant = "$req->{'fastq_dir'}$req->{'ugp_id'}_FINAL.vcf";

    ( my $output_snp = $snp_variant ) =~
      s/_applyed_filtered_SNP.vcf/_applyed_filtered_SNP_subset.vcf/;
    ( my $output_indel = $indel_variant ) =~
      s/_applyed_filtered_INDEL.vcf/_applyed_filtered_INDEL_subset.vcf/;

	system("touch $output_snp $output_indel $final_variant");

    my $snp_opts   = options( 'SelectVariants_SNP',   '--' ) || '';
    my $indel_opts = options( 'SelectVariants_INDEL', '--' ) || '';
    my $final_opts = options( 'CombineVariants',      '--' ) || '';

    my $svs_cmd =
	"java -Xmx$req->{'gatk_pr_Xmx'}g -jar -Djava.io.tmpdir=$req->{'java_tmp'} "
      . "$soft->{'gatk'}GenomeAnalysisTK.jar -T SelectVariants -R $req->{'fasta'} $snp_opts "
      . "$sn --variant $snp_variant -o $output_snp &> SelectVariants_SNP.report";

    push @{ $cmd_list{'SelectVariants_SNP'} }, $svs_cmd;

    my $svi_cmd =
	"java -Xmx$req->{'gatk_pr_Xmx'}g -jar -Djava.io.tmpdir=$req->{'java_tmp'} "
      . "$soft->{'gatk'}GenomeAnalysisTK.jar -T SelectVariants -R $req->{'fasta'} $indel_opts "
      . "$sn --variant $indel_variant -o $output_indel &> SelectVariants_INDEL.report";

    push @{ $cmd_list{'SelectVariants_INDEL'} }, $svi_cmd;

    my $cv_cmd =
	"java -Xmx$req->{'gatk_pr_Xmx'}g -jar -Djava.io.tmpdir=$req->{'java_tmp'} "
      . "$soft->{'gatk'}GenomeAnalysisTK.jar -T CombineVariants -R $req->{'fasta'} $final_opts "
      . "--variant $output_snp --variant $output_indel -o $final_variant &> CombineVariants.report";

    push @{ $cmd_list{'CombineVariants'} }, $cv_cmd;
	return;
}

#-------------------------------------------------------------------------------

close STDERR;

