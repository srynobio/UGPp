#!/usr/bin/perl
# cApTUrE: vAriant collecTing UGP pipelinE
use strict;
use warnings;
use IO::File;
use IO::Dir;
use Config::Std;
use Getopt::Long;
use IPC::System::Simple qw (run capture);
use Parallel::ForkManager;

use Data::Dumper;

my $VERSION = '0.0.4';

my $usage = "

Description:
	
	clUsTEr: vAriant collecTing UGP pipeline version specialized for CHPC cluster environment : $VERSION

	clUsTEr is a PBS cluster pipeline written in Perl, modified from the 
	Utah Genome Project (UGP) cApTUrE pipeline to run in the CHPC cluster enviroment
	http://weatherby.genetics.utah.edu/UGP/wiki/index.php/Main_Page

	Currently it incorporates the following tools:
		-FastQC
		-bwa
		-samtools
		-Picard
		-GATK

	clUsTEr requires a config file given as the first commandline argument.
	And all instruction and requirement are given therein.

Options:
	--clean|c : Removes all list, pbs, and report files.

	--help|h  : Displays this usage statement.

\n";

my ( $arc, $clean, $mail, $passfqc, $rr, $help );
GetOptions(
    "clean|c"         => \$clean,
    "help|h"          => \$help,
);
die $usage if $help;

# capture clean
if ($clean) {
    system("rm -f *list *pbs* *.report");
    die "Cleaning up list and report files.\n";
}

my $conf_file = $ARGV[0] or die $usage;

# tracker for repeted_runs
my $times = '0';

# read the config file.
read_config $conf_file => my %config;

## file variables
my $req    = $config{'required'};
my $soft   = $config{'software'};
my $CMDLOG = IO::File->new( $req->{'command_log'}, 'a+' );

# pipeline progress report
my %progress_list =
  map { $_ => 'incomplete' } @{ $config{'order'}{'command_order'} };

# parallel process manager
my $pm = Parallel::ForkManager->new( $req->{'cpu'} );

# hash of all step of pipeline for PBS.
my %cmd_list;

run_cApTUre();

#-------------------------------------------------------------------------------
#                                   SUBS
#-------------------------------------------------------------------------------

sub run_cApTUre {
    my $PROG_FILE = IO::File->new( 'progress.log', 'a+' );

    # check for position in pipline
    if ( -e 'progress.log' and -s 'progress.log' ) {
        my @progress = `cat progress.log`;
        foreach my $complete (@progress) {
            chomp $complete;
            my ( $sub, $step ) = split /\:/, $complete;
            if ( $step eq 'complete' ) {
                $progress_list{$sub} = 'complete';
            }
        }
    }

    # dispatch table
    my $steps = {
        fastqc                 => \&fastqc,
        indexer                => \&indexer,
        bwa_mem                => \&bwa_mem,
        bwa_aln                => \&bwa_aln,
        bwa_sampe              => \&bwa_sampe,
        SortSam                => \&SortSam,
        idxstats               => \&idxstats,
        flagstat               => \&flagstat,
        MergeSamFiles          => \&MergeSamFiles,
        MarkDuplicates         => \&MarkDuplicates,
        RealignerTargetCreator => \&RealignerTargetCreator,
        IndelRealigner         => \&IndelRealigner,
        BaseRecalibrator       => \&BaseRecalibrator,
        PrintReads             => \&PrintReads,
        CollectMultipleMetrics => \&CollectMultipleMetrics,
        LeftAlignIndels        => \&LeftAlignIndels,
        ReduceReads            => \&ReduceReads,
        SNP                    => \&SNP,
        INDEL                  => \&INDEL,

        #        mail_user                 => \&mail_user("finished"),
    };

    print $CMDLOG "#############################################\n"
      . "cApTUrE run version $VERSION started on "
      . timestamp() . "\n"
      . "#############################################\n";

    # Run verify and each step of order list
    config_verify();
    foreach my $tool ( @{ $config{'order'}{'command_order'} } ) {
        next if ( $progress_list{$tool} eq 'complete' );
        $steps->{$tool}->();

        $progress_list{$tool} = 'complete';
        print $PROG_FILE "$tool:complete\n";
    }
    PBS_annotate();
    $PROG_FILE->close;
}

#-------------------------------------------------------------------------------
sub indexer {

    # dispatch table
    my $indexers = {
        bwa  => \&_bwa_index,
        gatk => \&_gatk_indexer,
    };

    # call each indexer
    foreach my $i ( keys %{$indexers} ) {
        $pm->start and next;
        $indexers->{$i}->();
        $pm->finish;
    }
    $pm->wait_all_children;
}

#-------------------------------------------------------------------------------

sub open_dir {
    my $dir = shift;
    my $DH  = IO::Dir->new($dir)
      or die_messenger("Could not open directory $dir.");
    return \$DH;
}

#-------------------------------------------------------------------------------

sub open_list {
    my $file = shift;

    my @list = `cat $file`;
    return \@list;
}

#-------------------------------------------------------------------------------

sub config_verify {

    # Check versions
    if ( $VERSION ne $req->{'ugp_version'} ) {
        die_messenger( "Software version: $VERSION and requested version: "
              . "$req->{'ugp_version'} do not match." );
    }

    # check that fastq dir hash trailing slash
    # as well as software paths.
    unless ( $req->{'fastq_dir'} =~ /\/$/ ) {
        $req->{'fastq_dir'} =~ s/$/\//;
    }

    foreach my $prog ( keys %{$soft} ) {
        unless ( $soft->{$prog} =~ /\/$/ ) {
            $soft->{$prog} =~ s/$/\//;
        }
    }

    # check for reference fasta.
    if ( !-e $req->{'fasta'} ) {
        die_messenger("Fasta file not found");
    }

    unless ( $config{'required'}{'known_indel'} ) {
        die_messenger(
            "Cant find known_indel file[s] for RealignerTargetCreator.");
    }

    if ( $req->{'unified_bg_bams'} ) {
        my $BKB = IO::File->new( 'background_bam.list', 'w' );
        my $bams = `find $req->{'unified_bg_bams'} -name "*reduced.bam"`;
        ($bams)
          ? print $BKB $bams
          : die_messenger("Cant find unified_bg_bams reduced bam file[s]");
        $BKB->close;
    }
}

#-------------------------------------------------------------------------------

sub file_verify {
    my @files = @_;

    my @file_list;
    foreach my $list (@files) {
        unless ( -e $list and -s $list ) {
            die_messenger("Can't find required $list file ");
        }
    }
}

#-------------------------------------------------------------------------------

sub die_messenger {
    my $message = shift;

    open( STDERR, ">>", 'Fatal_error.log' );

    print "Error occured $message\n";
    my $error = "FATAL: $message --";
    die $error;
}

#-------------------------------------------------------------------------------

sub timestamp {
    my $time = localtime;
    return $time;
}

#-------------------------------------------------------------------------------

sub start_log {
    my $program = shift;
    printf $CMDLOG "{cApTUrE} %s started %s: \n", $program, timestamp();
}

#-------------------------------------------------------------------------------

sub end_log {
    my $program = shift;
    printf $CMDLOG "{cApTUrE} %s finished %s: \n", $program, timestamp();
}

#-------------------------------------------------------------------------------

sub cmd_log {
    my $cmd = shift;
    printf $CMDLOG "{cApTUrE} {COMMAND} --> %s: \n", $cmd;
}

#-------------------------------------------------------------------------------

sub options {
    my ( $call, $flag ) = @_;
    my $section = $config{$call};

    my $opts;
    foreach my $options ( keys %{$section} ) {
        next unless ( $section->{$options} );
        if ( $section->{$options} eq 'TRUE' ) {
            $opts .= "$flag$options ";
        }
        elsif ( ref $section->{$options} eq 'ARRAY' ) {
            foreach my $known ( @{ $section->{$options} } ) {
                $opts .= "$flag$options $known ";
            }
        }
        elsif ( $section->{$options} ) {
            $opts .= "$flag$options $section->{$options} ";
        }
    }
    return $opts;
}

#-------------------------------------------------------------------------------

sub name_parse {
    my $path = shift;

    my @schema = split /\_/, $path;
    return @schema;
}

#-------------------------------------------------------------------------------

sub mail_user {
    my ( $message, $reason ) = @_;
    $reason ||= 'cApTUrE';

    if ($mail) {
        system("mail -s \"$message: $reason\" $mail < Fatal_error.log");
        system("mail -s \"$message: $reason\" $mail < cmd.log");
        system("mail -s \"$message: $reason\" $mail < progress.log");
    }
}

#-------------------------------------------------------------------------------

sub qstat_check {
    my @lt = `qstat -u u0413537`;

    my $running = 0;
    foreach my $jobs (@lt) {
        chomp $jobs;
        next unless ( $jobs =~ /^\d+/ );
        my @report = split /\s/, $jobs;

        my @list = grep { /R/ } @report;

        if (@list) { $running++ }
    }
    return $running;
}

#-------------------------------------------------------------------------------

###### md5 ######
# still need to add to this sub.

sub md5sum {
    start_log('md5sum');

    my $FQDIR = open_dir( $req->{'fastq_dir'} );

    foreach my $fq ( $$FQDIR->read ) {
        next unless ( $fq =~ /\.(fastq.gz|fq.gz)$/ );

        ( my $md = $fq ) =~ s/\.(fastq.gz|fq.gz)$/\.md5/;
        my $cmd = "md5sum $fq > $md";
        cmd_log($cmd);
        runner($cmd);
    }
    $$FQDIR->close;

    # Now collect the md5 files.
    my $MDDIR = open_dir( $req->{'md5'} );

    foreach my $md5 ( $MDDIR->read ) {
        next unless ( $md5 =~ /\.md5$/ );
        ### check to file to each other useing diff.
    }

    end_log('md5sum');
}

#-------------------------------------------------------------------------------

###### fastqc ######

sub fastqc {
    my $opts = options( 'fastqc', '--' ) || '';
    my $FQDIR = open_dir( $req->{'fastq_dir'} );

    # make a fastq directory
    my $output_dir = "$req->{'fastq_dir'}fastqc";
    `mkdir $output_dir`;

    foreach my $file ( $$FQDIR->read ) {
        next unless ( $file =~ /\.gz$/ );

        my $input = "$req->{'fastq_dir'}$file";
        my $output;
        if ( $file =~ /\.gz/ ) {
            ( $output = $input ) =~ s/.gz$//;
        }
        else { $output = $input; }

        my @p_file = name_parse($file);

        #fastqc needs files to be unzipped.
        unless ( -e $output ) {
            my $gun = "gunzip -c $input > $output";
            push @{ $cmd_list{ $p_file[0] } }, $gun;
        }

        system("touch $output $output_dir");
        my $cmd = "$soft->{'fastqc'}fastqc $opts -o $output_dir -f fastq $output 2>> fastQC.report";
        push @{ $cmd_list{ $p_file[0] } }, $cmd;
    }
    $$FQDIR->close;
    ####fastq_reviewer() unless $passfqc;
}

#-------------------------------------------------------------------------------

sub fastq_reviewer {
    my @summaries = `find $req->{'fastq_dir'} -name "summary.txt"`;
    die_messenger("Can't fine fastqc summary.txt files.")
      if scalar @summaries < 1;

    my $fail = 0;
    foreach my $report (@summaries) {
        my @results = `cat $report`;

        foreach my $i (@results) {
            if ( $i =~ /^FAIL/ ) {
                $fail++;
            }
        }
    }
    ( $fail > 0 and !$passfqc )
      ? die_messenger("one or more fastqc tests failed")
      : return;
}

#-------------------------------------------------------------------------------

###### BWA ######

sub _bwa_index {
    start_log('bwa_index');

    my $opts = options( 'bwa_index', '-' ) || '';

    my $cmd =
      "$soft->{'bwa'}bwa index $opts $req->{'fasta'} 2>> bwa_index.report";
    cmd_log($cmd);
    runner($cmd);
    end_log('bwa_index');
}

#-------------------------------------------------------------------------------

sub bwa_mem {
    my $opts = options( 'bwa_mem', '-' ) || '';
    my $FQDIR = open_dir( $req->{'fastq_dir'} );

    my @fq_files;
    foreach my $i ( $$FQDIR->read ) {
        chomp $i;
        next if ( $i !~ /.gz$/ );

        push @fq_files, $i;
    }
    my @sorted_fqs = sort { $a cmp $b } @fq_files;

    my %fq_hash;
    foreach my $f (@sorted_fqs) {
        chomp $f;

        my @parts = split "_", $f;
        push @{ $fq_hash{ $parts[0] } }, $f;
    }

    my $id = '1';
    my @mem_cmds;
    for ( my $i = 0 ; $i < scalar @fq_files ; $i += 2 ) {

        foreach my $g ( keys %fq_hash ) {

            my $fq1 = $fq_hash{$g}[$i];
            my $fq2 = $fq_hash{$g}[ $i + 1 ];
            next unless ( $fq1 && $fq2 );

            # paths
            my $fq1_path = "$req->{'fastq_dir'}$fq1";
            my $fq2_path = "$req->{'fastq_dir'}$fq2";
            my $reads    = "$fq1_path $fq2_path";

            #take the first file which will work
            my @p_file = name_parse($fq1);

            # create ordered bam files.
            ( my $bam_name = $fq1 ) =~ s/(.*)\.(.*)\.gz/$1.bam/;
            my $bam_file = "$req->{'fastq_dir'}$bam_name";

            my $r_group = '\'@RG'
              . "\\tID:$id\\tSM:$p_file[0]\\tPL:ILLUMINA\\tLB:$p_file[0]\'";

            my $cmd =
                "$soft->{'bwa'}bwa mem -M -R $r_group $opts $req->{'fasta'} "
              . "$reads 2>> bwa_mem.report | $soft->{'samtools'}samtools view "
              . "-bSho $bam_file - 2>> samtools_bam.report";

            push @mem_cmds, $cmd;
            $id++;
        }
    }

    # run each command on a separate process.
    start_log('bwa_mem');
    foreach my $command (@mem_cmds) {
        $pm->start and next;
        cmd_log($command);
        runner($command);
        $pm->finish;
    }
    $pm->wait_all_children;
    end_log('bwa_mem');

    $$FQDIR->close;
}

#-------------------------------------------------------------------------------

sub bwa_aln {
    my $opts = options( 'bwa_aln', '-' ) || '';
    my $FQDIR = open_dir( $req->{'fastq_dir'} );

    foreach my $file ( $$FQDIR->read ) {
        next unless ( $file =~ /\.gz/ );

        my @p_file = name_parse($file);

        ( my $sai_name = $file ) =~ s/(.*)\.(.*)\.gz/$1.sai/;
        my $sai_file = "$req->{'fastq_dir'}$sai_name";

        system("touch $sai_file");

        my $cmd = "$soft->{'bwa'}bwa aln $opts $req->{'fasta'} "
          . "$req->{'fastq_dir'}$file > $sai_file 2>> bwa_aln.report";

        push @{ $cmd_list{ $p_file[0] } }, $cmd;
    }
    $$FQDIR->close;
    return;
}

#-------------------------------------------------------------------------------

sub PBS_annotate {

    my @pbs;

    foreach my $set ( keys %cmd_list ) {
        my $FH = IO::File->new( "$set.pbs", 'a+' ) or die;
        push @pbs, "$set.pbs";

        print $FH "
#PBS -S /bin/bash
#PBS -l nodes=1:ppn=12,walltime=24:00:00
#PBS -A yandell-em
#PBS -M shawn.rynearson\@gmail.com	
source /uufs/chpc.utah.edu/common/home/u0413537/.bash_profile
date
\n";
        foreach my $group ( @{ $cmd_list{$set} } ) {
            print $FH $group, "\n";
        }
        print $FH "date";
        $FH->close;
    }

    foreach my $qsub (@pbs) {
        next if $qsub =~ /SNP*|INDEL*/;
        print "qsub $qsub &>> qsub_order\n";
        system "qsub $qsub &>> qsub_order";
    }

    foreach my $qsub (@pbs) {
        next unless $qsub =~ /SNP*|INDEL*/;
        my @jobs = `cat qsub_order`;
        my @before;
        foreach my $i (@jobs) {
            chomp $i;
            push @before, $i;
        }
        my $wait = join( ":", @before );
        print "qsub -W depend=afterok:$wait $qsub\n";
        system "qsub -W depend=afterok:$wait $qsub";
    }
    return;
}

#-------------------------------------------------------------------------------

sub bwa_sampe {

    my $opts = options( 'bwa_sampe', '-' ) || '';
    my $DH = open_dir( $req->{'fastq_dir'} );

    my ( @sai, @fq );
    foreach my $file ( $$DH->read ) {
        next unless ( $file =~ /(gz||sai)$/ );
        if ( $file =~ /sai$/ ) {
            push @sai, $file;
        }
        elsif ( $file =~ /.gz$/ ) {
            push @fq, $file;
        }
    }
    my @sort_fq  = sort { $a cmp $b } @fq;
    my @sort_sai = sort { $a cmp $b } @sai;

    # check that the sai files are even.
    if ( scalar @sort_sai % 2 ) {
        die_messenger(
            "sai file look inconsistent, must only have two per fastq file.");
    }

    my $id = '1';
    while (@sort_fq) {

        my @sq = splice( @sort_fq,  0, 2 );
        my @ss = splice( @sort_sai, 0, 2 );

        # update with path information.
        my @sa  = map { "$req->{'fastq_dir'}$_" } @ss;
        my @sfq = map { "$req->{'fastq_dir'}$_" } @sq;

        my @p_file = name_parse( $ss[0] );

        # create ordered bam files.
        ( my $bam_name = $sq[0] ) =~ s/(.*)\.(.*)\.gz/$1.bam/;
        my $bam_file = "$req->{'fastq_dir'}$bam_name";

        my $r_group =
          '\'@RG' . "\\tID:$id\\tSM:$p_file[0]\\tPL:ILLUMINA\\tLB:$p_file[0]\'";

        # touch output file for downstream cmds.
        system("touch $bam_file");

        my $cmd =
	    "$soft->{'bwa'}bwa sampe -r $r_group $opts $req->{'fasta'} $sa[0] $sa[1] "
          . "$sfq[0] $sfq[1] | $soft->{'samtools'}samtools view -bSho $bam_file - &>> bwa_sampe.report";

        push @{ $cmd_list{ $p_file[0] } }, $cmd;
        $id++;
    }
    $$DH->close;
}

#-------------------------------------------------------------------------------

###### Picard and Samtools ######

sub SortSam {
    my $DIR = open_dir( $req->{'fastq_dir'} );
    my $SORTLIST = IO::File->new( 'sorted_bam.list', 'w' );

    # get and order
    my $opts = options( 'SortSam', '=' ) || '';
    $opts =~ s/\=(\S+) /$1=/g;

    foreach my $bam ( $$DIR->read ) {
        next unless ( $bam =~ /\.bam$/ );
        next if ( $bam =~ /\_sorted.bam/ );

        my @p_file = name_parse($bam);

        # fasta dir
        my $dir = $req->{'fastq_dir'};
        ( my $sort_file = $bam ) =~ s/\.bam$/\_sorted.bam/;

        # touch output file for downstream cmds.
        system("touch $dir$sort_file");

        my $cmd =
            "java -jar -XX:ParallelGCThreads=$req->{'picard_java_threads'} "
          . "-Xmx$req->{'picard_java_Xmx'}g -Djava.io.tmpdir=$req->{'java_tmp'} "
          . "$soft->{'picard'}SortSam.jar INPUT=$dir$bam OUTPUT=$dir$sort_file "
          . "$opts &>> SortSam.report";

        push @{ $cmd_list{ $p_file[0] } }, $cmd;
        print $SORTLIST "$dir$sort_file\n";
    }
    $$DIR->close;
    $SORTLIST->close;
}

#-------------------------------------------------------------------------------

sub idxstats {
    my $DIR = open_dir( $req->{'fastq_dir'} );

    foreach my $bam ( $$DIR->read ) {
        next unless ( $bam =~ /\_sorted.bam/ );
        ( my $idx_file = $bam ) =~ s/\.bam/\.stats/;

        my $idx_cmd = "$soft->{'samtools'}samtools idxstats $req->{'fastq_dir'}$bam > $req->{'fastq_dir'}$idx_file 2>> idxstats.report";
    }
    $DIR->close;
}

#-------------------------------------------------------------------------------

sub flagstat {
    my $DIR = open_dir( $req->{'fastq_dir'} );

    foreach my $bam ( $$DIR->read ) {
        next unless ( $bam =~ /\_sorted.bam$/ );

        my $dir = $req->{'fastq_dir'};
        ( my $flag_file = $bam ) =~ s/\.bam/.flagstat/;

        my @p_file = name_parse($bam);
        system("touch $dir$flag_file");

        my $cmd = "$soft->{'samtools'}samtools flagstat $dir$bam > $dir$flag_file 2>> flagstat.report";
        push @{ $cmd_list{ $p_file[0] } }, $cmd;
    }
    $$DIR->close;
}

### add flagstat reviewer

#-------------------------------------------------------------------------------

###### Picard ######

sub _BuildBamIndex {
    my $file = shift;

    my $cmd =
	"java -Xmx$req->{'picard_java_Xmx'}g -XX:ParallelGCThreads=$req->{'picard_java_threads'} "
      . "-Djava.io.tmpdir=$req->{'java_tmp'} -jar "
      . "$soft->{'picard'}BuildBamIndex.jar INPUT=$file &>> BamIndex.report";
}

#-------------------------------------------------------------------------------

sub MarkDuplicates {
    my $DDLIST = IO::File->new( 'dedup_bam.list', 'w' );

    # created this section because if working with just pairs MergeSamFile
    # could be unused, although it will not fail.
    my $list_file;
    ( -e 'merged_bam.list' and -s 'merged_bam.list' ) ? $list_file =
      'merged_bam.list'
      : ( -e 'sorted_bam.list' and -s 'sorted_bam.list' ) ? $list_file =
      'sorted_bam.list'
      : die_messenger("sorted_bam.list or merged_bam.list not found.");

    my $opened = open_list($list_file);

    my $opts = options( 'MarkDuplicates', '=' ) || '';
    $opts =~ s/\=(\S+) /$1=/g;

    my %dedup;
    foreach my $bam ( @{$opened} ) {
        chomp $bam;

        ( my $output = $bam ) =~ s/\.bam/_Dedup.bam/;
        ( my $metric = $bam ) =~ s/\.bam/_Dedup.metrics/;

        # split up the commandline to the needed group name
        my @f_name = split /\//, $bam;
        my @p_file = name_parse( $f_name[-1] );

        # create a new merge file of dedups.
        $dedup{$output} = '1';

        system("touch $output");

        my $cmd =
	    "java -Xmx$req->{'picard_java_Xmx'}g -XX:ParallelGCThreads=$req->{'picard_java_threads'} "
          . "-Djava.io.tmpdir=$req->{'java_tmp'} -jar "
          . "$soft->{'picard'}MarkDuplicates.jar INPUT=$bam OUTPUT=$output METRICS_FILE=$metric "
          . "$opts &>> MarkDuplicates.report";

        push @{ $cmd_list{ $p_file[0] } }, $cmd;
    }

    # print the dedup_bam.list file.
    map { print $DDLIST "$_\n" } keys %dedup;

    $DDLIST->close;
}

#-------------------------------------------------------------------------------

sub MergeSamFiles {

    # files will always have to be sorted, to use this function.
    file_verify('sorted_bam.list');
    my $opened = open_list('sorted_bam.list');

    my $BAMLIST = IO::File->new( 'merged_bam.list', 'a+' );

    # get and order
    my $opts = options( 'MergeSamFiles', '=' ) || '';
    $opts =~ s/\=(\S+) /$1=/g;

    my %merge;
    foreach my $file ( @{$opened} ) {
        chomp $file;
        $file =~ s/$req->{'fastq_dir'}//;
        my @p_file = name_parse($file);

        # p_file[0] is the individual
        push @{ $merge{ $p_file[0] } }, $file;
    }

  # Will return if were trying to merge single files, which we don't need to do.
    my $single;
    my @sam_list = map { @{ $merge{$_} } } keys %merge;
    if ( scalar @sam_list == scalar keys %merge ) {
        $single = 'yes';
    }
    if ($single) { return }

    my %merge_list;
    foreach my $bam ( keys %merge ) {
        my $input = join( ':', @{ $merge{$bam} } );

        my @p_file = name_parse($bam);

        # add the paths and input/output tags
        $input =~ s/^/INPUT=$req->{'fastq_dir'}/;
        $input =~ s/:/ INPUT=$req->{'fastq_dir'}/g;
        my $output = "$req->{'fastq_dir'}$bam" . "_merged.bam";

        # This is what creates the merged_bam.list hash for the religners
        my $merge_bam = "$req->{'fastq_dir'}$bam" . "_merged.bam";
        $merge_list{$merge_bam} = '1';

        system("touch $output");

        my $cmd =
	    "java -Xmx$req->{'picard_java_Xmx'}g -XX:ParallelGCThreads=$req->{'picard_java_threads'} "
          . "-Djava.io.tmpdir=$req->{'java_tmp'} -jar "
          . "$soft->{'picard'}MergeSamFiles.jar $opts $input OUTPUT=$output 2>> MergeSamFiles.report";

        push @{ $cmd_list{ $p_file[0] } }, $cmd;
    }

    # print the merge_bam_list file.
    map { print $BAMLIST "$_\n"; } keys %merge_list;

    $BAMLIST->close;
    return;
}

#-------------------------------------------------------------------------------

sub CollectMultipleMetrics {
    my $opts = options( 'CollectMultipleMetrics', '=' ) || '';
    $opts =~ s/\=(\S+) /$1=/g;

    file_verify('recal_bam.list');
    my $opened = open_list('recal_bam.list');

    foreach my $bam ( @{$opened} ) {
        chomp $bam;

        ( my $w_file = $bam ) =~ s/\.bam$/\.metrics/;

        my $cmd =
	    "java -Xmx$req->{'picard_java_Xmx'}g -XX:ParallelGCThreads=$req->{'picard_java_threads'} "
          . "-Djava.io.tmpdir=$req->{'java_tmp'} -jar "
          . "$soft->{'picard'}CollectMultipleMetrics.jar INPUT=$bam $opts "
          . "REFERENCE_SEQUENCE=$req->{'fasta'} OUTPUT=$w_file 2>> CollectMultipleMetrics.report";

        my @f_name = split /\//, $bam;
        my @p_file = name_parse( $f_name[-1] );

        push @{ $cmd_list{ $p_file[0] } }, $cmd;
    }
    return;
}

#-------------------------------------------------------------------------------

###### GATK ######

sub _gatk_indexer {

    # gatk required use, but is a picard tool
    my $picard = "$soft->{'picard'}CreateSequenceDictionary.jar";
    my $fasta  = "$req->{'fasta'}";
    my $output = "$req->{'fasta'}";

    start_log('GATK_INDEXING');

    $output =~ s/(.*)\.(fasta|fa)/$1.dict/;
    my $picard_cmd = "java -jar $picard R=$fasta O=$output 2>> seq_dict.report";
    cmd_log($picard_cmd);
    runner("$picard_cmd");

    # now run to prepare the fasta index file.
    my $samtools = "$soft->{'samtools'}samtools faidx";
    my $sam_cmd  = "$samtools $fasta";
    cmd_log($sam_cmd);
    runner("$sam_cmd");

    end_log('GATK_INDEXING');
}

#-------------------------------------------------------------------------------

sub RealignerTargetCreator {
    my @knowns = @{ $config{'required'}{'known_indel'} };
    my $opts = options( 'RealignerTargetCreator', '--' ) || '';

    my $known_vcfs;
    foreach my $vcf (@knowns) {
        chomp $vcf;
        next unless ( $vcf =~ /\.vcf$/ );
        $known_vcfs .= "--known $vcf ";
    }

    file_verify('dedup_bam.list');
    my $opened = open_list('dedup_bam.list');

    my $id = 1;
    foreach my $bam ( @{$opened} ) {
        chomp $bam;
        my $output =
          "$req->{'fastq_dir'}$req->{'ugp_id'}_realign.intervals_$id";
        $id++;

        # split up the commandline to the needed group name
        my @f_name = split /\//, $bam;
        my @p_file = name_parse( $f_name[-1] );

        system("touch $output");

        my $cmd =
	    "java -Xmx$req->{'gatk_tc_Xmx'}g -jar -Djava.io.tmpdir=$req->{'java_tmp'} "
          . "$soft->{'gatk'}GenomeAnalysisTK.jar -T RealignerTargetCreator -R $req->{'fasta'} -I $bam $opts "
          . "$known_vcfs -o $output &>> RealignerTargetCreator.report";

        my $cat_cmd = "cat $output >> $req->{'fastq_dir'}$req->{'ugp_id'}_realign.intervals";
        push @{ $cmd_list{ $p_file[0] } }, $cmd, $cat_cmd;
    }
    return;
}

#-------------------------------------------------------------------------------

sub IndelRealigner {
    my $INDEL_LIST = IO::File->new( 'realign_bam.list', 'w' );
    my $opts   = options( 'IndelRealigner', '--' ) || '';
    my $target = "$req->{'fastq_dir'}$req->{'ugp_id'}_realign.intervals";
    my @knowns = @{ $config{'required'}{'known_indel'} };

    my $known_vcfs;
    foreach my $vcf (@knowns) {
        chomp $vcf;
        next unless ( $vcf =~ /\.vcf$/ );
        $known_vcfs .= "--knownAlleles $vcf ";
    }
    file_verify('dedup_bam.list');
    my $opened = open_list('dedup_bam.list');

    my %indel_list;
    foreach my $dedup ( @{$opened} ) {
        chomp $dedup;

        next unless ( $dedup =~ /\.bam$/ );
        ( my $output = $dedup ) =~ s/\.bam/_realign.bam/;

        $indel_list{$output} = '1';

        system("touch $output");
        my $cmd =
	    "java -Xmx$req->{'gatk_ir_Xmx'}g -jar -XX:ParallelGCThreads=$req->{'picard_java_threads'} "
          . "-Djava.io.tmpdir=$req->{'java_tmp'} $soft->{'gatk'}GenomeAnalysisTK.jar -T IndelRealigner -R $req->{'fasta'} "
          . " -I $dedup $opts -targetIntervals $target $known_vcfs -o $output &>> IndelRealigner.report";

        my @f_name = split /\//, $dedup;
        my @p_file = name_parse( $f_name[-1] );

        push @{ $cmd_list{ $p_file[0] } }, $cmd;
    }

    # create the list file.
    map { print $INDEL_LIST "$_\n" } keys %indel_list;
    $INDEL_LIST->close;

    return;
}

#-------------------------------------------------------------------------------

sub ReduceReads {
    my $opts = options( 'ReduceReads', '--' ) || '';
    my $RD_LIST = IO::File->new( 'reduced_bam.list', 'w' );

    file_verify('recal_bam.list');
    my $opened = open_list('recal_bam.list');

    my %reduced;
    foreach my $bam ( @{$opened} ) {
        chomp $bam;
        ( my $output = $bam ) =~ s/\.bam$/_reduced.bam/;

        $reduced{$output} = '1';

        my $cmd =
	    "java -Xmx$req->{'gatk_rr_Xmx'}g -jar -Djava.io.tmpdir=$req->{'java_tmp'} "
          . "-XX:ParallelGCThreads=$req->{'picard_java_threads'} $soft->{'gatk'}GenomeAnalysisTK.jar "
          . "-T ReduceReads -R $req->{'fasta'} -I $bam $opts "
          . "-o $output &>> ReduceReads.report";

        my @f_name = split /\//, $bam;
        my @p_file = name_parse( $f_name[-1] );

        push @{ $cmd_list{ $p_file[0] } }, $cmd;
    }

    # create the list file.
    map { print $RD_LIST $_, "\n" } keys %reduced;
    $RD_LIST->close;
    return;
}

#-------------------------------------------------------------------------------

sub BaseRecalibrator {
    my $opts = options( 'BaseRecalibrator', '--' ) || '';
    my $output = "$req->{'fastq_dir'}$req->{'ugp_id'}_recal_data.table";

    file_verify('realign_bam.list');
    my $opened_bams = open_list('realign_bam.list');

    my @known_lists = @{ $config{'required'}{'known_indel'} };
    my $dbsnp       = $config{'required'}{'known_dbsnp'};
    push @known_lists, $dbsnp;

    my $known_vcfs;
    foreach my $vcf (@known_lists) {
        chomp $vcf;
        next unless ( $vcf =~ /\.vcf$/ );
        $known_vcfs .= "--knownSites $vcf ";
    }

    foreach my $bam ( @{$opened_bams} ) {
        chomp $bam;

        my $cmd =
	    "java -Xmx$req->{'gatk_br_Xmx'}g -jar -Djava.io.tmpdir=$req->{'java_tmp'} "
          . "$soft->{'gatk'}GenomeAnalysisTK.jar -T BaseRecalibrator -R $req->{'fasta'} -I $bam $opts "
          . "$known_vcfs -o $output &>> BaseRecalibrator.report";

        my @f_name = split /\//, $bam;
        my @p_file = name_parse( $f_name[-1] );

        push @{ $cmd_list{ $p_file[0] } }, $cmd;
    }
    return;
}

#-------------------------------------------------------------------------------

sub PrintReads {
    my $opts       = options( 'PrintReads', '--' ) || '';
    my $bqsr       = "$req->{'fastq_dir'}$req->{'ugp_id'}_recal_data.table";
    my $RECAL_LIST = IO::File->new( 'recal_bam.list', 'w' );

    file_verify('realign_bam.list');
    my $opened = open_list('realign_bam.list');

    my %recal;
    foreach my $bam ( @{$opened} ) {
        chomp $bam;

        my ($output) = $bam =~ /(.*)\.bam/;
        $output =~ s/$/_recal.bam/;

        $recal{$output} = 1;

        my $cmd =
	    "java -Xmx$req->{'gatk_pr_Xmx'}g -jar -Djava.io.tmpdir=$req->{'java_tmp'} "
          . "$soft->{'gatk'}GenomeAnalysisTK.jar -T PrintReads -R $req->{'fasta'} -I $bam $opts "
          . "-BQSR $bqsr -o $output &>> PrintReads.report";

        my @f_name = split /\//, $bam;
        my @p_file = name_parse( $f_name[-1] );

        push @{ $cmd_list{ $p_file[0] } }, $cmd;

    }

    # create the list file.
    map { print $RECAL_LIST $_, "\n" } keys %recal;
    $RECAL_LIST->close;
    return;
}

#-------------------------------------------------------------------------------

sub SNP {
    my $unifed_snp   = UnifiedGenotyper_SNP();
    my $unifed_recal = VariantRecalibrator_SNP();
    my $appled_snp   = ApplyRecalibration_SNP();

    push @{ $cmd_list{'SNP'} }, $unifed_snp, $unifed_recal, $appled_snp;
}

#-------------------------------------------------------------------------------

sub INDEL {
    my $unifed_indel = UnifiedGenotyper_INDEL();
    my $unifed_recal = VariantRecalibrator_INDEL();
    my $appled_indel = ApplyRecalibration_INDEL();

    push @{ $cmd_list{'INDEL'} }, $unifed_indel, $unifed_recal, $appled_indel;
}

#-------------------------------------------------------------------------------

sub UnifiedGenotyper_SNP {
    my $opts = options( 'UnifiedGenotyper_SNP', '--' ) || '';
    my $output = "$req->{'fastq_dir'}$req->{'ugp_id'}_raw_snp.vcf";

    system("touch $output");

    my $opened = open_list('reduced_bam.list');

    my $background;
    if ( $req->{'unified_bg_bams'} ) {
        file_verify('background_bam.list');
        my $bams = open_list('background_bam.list');

        foreach my $backs ( @{$bams} ) {
            chomp $backs;
            $background .= "-I $backs ";
        }
    }

    my $input_bams;
    foreach my $bam ( @{$opened} ) {
        chomp $bam;
        $input_bams .= "-I $bam ";
    }

    my $cmd =
	"java -Xmx$req->{'gatk_ug_Xmx'}g -jar -Djava.io.tmpdir=$req->{'java_tmp'} "
      . "$soft->{'gatk'}GenomeAnalysisTK.jar -T UnifiedGenotyper -R $req->{'fasta'} $input_bams $background "
      . "$opts -o $output &>> UnifiedGenotyper_SNP.report";

    return $cmd;
}

#-------------------------------------------------------------------------------

sub UnifiedGenotyper_INDEL {
    my $opts = options( 'UnifiedGenotyper_INDEL', '--' ) || '';
    my $output = "$req->{'fastq_dir'}$req->{'ugp_id'}_raw_indel.vcf";

    system("touch $output");

    my $opened = open_list('reduced_bam.list');

    my $background;
    if ( $req->{'unified_bg_bams'} ) {
        file_verify('background_bam.list');
        my $bams = open_list('background_bam.list');

        foreach my $backs ( @{$bams} ) {
            chomp $backs;
            $background .= "-I $backs ";
        }
    }

    my $input_bams;
    foreach my $bam ( @{$opened} ) {
        chomp $bam;
        $input_bams .= "-I $bam ";
    }

    my $cmd =
	"java -Xmx$req->{'gatk_ug_Xmx'}g -jar -Djava.io.tmpdir=$req->{'java_tmp'} "
      . "$soft->{'gatk'}GenomeAnalysisTK.jar -T UnifiedGenotyper -R $req->{'fasta'} $input_bams $background "
      . "$opts -o $output &>> UnifiedGenotyper_INDEL.report";

    return $cmd;
}

#-------------------------------------------------------------------------------

sub VariantRecalibrator_SNP {

    my $input = "$req->{'fastq_dir'}$req->{'ugp_id'}_raw_snp.vcf";

    my @vqsr;
    if ( ref $config{'required'}{'vqsr_snp_vcf'} eq 'ARRAY' ) {
        @vqsr = @{ $config{'required'}{'vqsr_snp_vcf'} };
    }
    else {
        push @vqsr, $config{'required'}{'vqsr_snp_vcf'};
    }

    my @snp_file;
    if ( ref $config{'VariantRecalibrator_SNP'}{'resource'} eq 'ARRAY' ) {
        @snp_file = @{ $config{'VariantRecalibrator_SNP'}{'resource'} };
    }
    else {
        push @snp_file, $config{'VariantRecalibrator_SNP'}{'resource'};
    }

    # shift in order the resource lines.
    my $resource_call;
    if (@vqsr) {
        while ( my $site = @vqsr ) {
            my $resource = shift @snp_file;
            my $file     = shift @vqsr;
            $resource_call .= "--resource:$resource $file ";
        }

        # remove the resource info from the config hash
        delete $config{'VariantRecalibrator_SNP'}{'resource'};
    }

    # now run options to get others
    my $opts = options( 'VariantRecalibrator_SNP', '--' ) || '';

    my $recalFile = "-recalFile $req->{'fastq_dir'}$req->{'ugp_id'}_snp_recal";
    my $tranchFile =
      "-tranchesFile $req->{'fastq_dir'}$req->{'ugp_id'}_snp_tranches";
    my $rscriptFile =
      "-rscriptFile $req->{'fastq_dir'}$req->{'ugp_id'}_snp_plots.R";

    # big ugly system call to make needed recal tranch and rscript files.
    system( 
	"touch $req->{'fastq_dir'}$req->{'ugp_id'}_snp_recal $req->{'fastq_dir'}$req->{'ugp_id'}_snp_tranches $req->{'fastq_dir'}$req->{'ugp_id'}_snp_plots.R"
    );

    my $cmd =
	"java -Xmx$req->{'gatk_pr_Xmx'}g -jar -Djava.io.tmpdir=$req->{'java_tmp'} "
      . "$soft->{'gatk'}GenomeAnalysisTK.jar -T VariantRecalibrator -R $req->{'fasta'} -input $input $resource_call "
      . "$opts $recalFile $tranchFile $rscriptFile -mode SNP &>> VariantRecalibrator_SNP.report";

    return $cmd;
}

#-------------------------------------------------------------------------------

sub VariantRecalibrator_INDEL {
    my $input = "$req->{'fastq_dir'}$req->{'ugp_id'}_raw_indel.vcf";

    my @vqsr;
    if ( ref $config{'required'}{'vqsr_indel_vcf'} eq 'ARRAY' ) {
        @vqsr = @{ $config{'required'}{'vqsr_indel_vcf'} };
    }
    else {
        push @vqsr, $config{'required'}{'vqsr_indel_vcf'};
    }

    my @indel_file;
    if ( ref $config{'VariantRecalibrator_INDEL'}{'resource'} eq 'ARRAY' ) {
        @indel_file = @{ $config{'VariantRecalibrator_INDEL'}{'resource'} };
    }
    else {
        push @indel_file, $config{'VariantRecalibrator_INDEL'}{'resource'};
    }

    my $resource_call;
    if (@vqsr) {
        while ( my $site = @vqsr ) {
            my $resource = shift @indel_file;
            my $file     = shift @vqsr;
            $resource_call .= "--resource:$resource $file ";
        }

        # remove the resource info from the config hash
        delete $config{'VariantRecalibrator_INDEL'}{'resource'};
    }

    # now run options to get others
    my $opts = options( 'VariantRecalibrator_INDEL', '--' ) || '';

    my $recalFile =
      "-recalFile $req->{'fastq_dir'}$req->{'ugp_id'}_indel_recal";
    my $tranchFile =
      "-tranchesFile $req->{'fastq_dir'}$req->{'ugp_id'}_indel_tranches";
    my $rscriptFile =
      "-rscriptFile $req->{'fastq_dir'}$req->{'ugp_id'}_indel_plots.R";

    # big ugly system call to make needed recal tranch and rscript files.
    system(
	"touch $req->{'fastq_dir'}$req->{'ugp_id'}_indel_recal $req->{'fastq_dir'}$req->{'ugp_id'}_indel_tranches $req->{'fastq_dir'}$req->{'ugp_id'}_indel_plots.R"
    );

    my $cmd =
	"java -Xmx$req->{'gatk_pr_Xmx'}g -jar -Djava.io.tmpdir=$req->{'java_tmp'} "
      . "$soft->{'gatk'}GenomeAnalysisTK.jar -T VariantRecalibrator -R $req->{'fasta'} -input $input $resource_call "
      . "$opts $recalFile $tranchFile $rscriptFile -mode INDEL &>> VariantRecalibrator_INDEL.report";

    return $cmd;
}

#-------------------------------------------------------------------------------

sub ApplyRecalibration_SNP {
    my $recalFile  = "$req->{'fastq_dir'}$req->{'ugp_id'}_snp_recal";
    my $tranchFile = "$req->{'fastq_dir'}$req->{'ugp_id'}_snp_tranches";
    my $input      = "$req->{'fastq_dir'}$req->{'ugp_id'}_raw_snp.vcf";
    ( my $output = $input ) =~ s/_raw_snp.vcf/_applyed_filtered_SNP.vcf/;
    my $opts = options( 'ApplyRecalibration_SNP', '--' ) || '';

    system("touch $output");

    my $cmd =
	"java -Xmx$req->{'gatk_pr_Xmx'}g -jar -Djava.io.tmpdir=$req->{'java_tmp'} "
      . "$soft->{'gatk'}GenomeAnalysisTK.jar -T ApplyRecalibration -R $req->{'fasta'} -input $input "
      . "$opts -recalFile  $recalFile -tranchesFile $tranchFile -mode SNP -o $output &>> ApplyRecalibration_SNP.report";

    return $cmd;
}

#-------------------------------------------------------------------------------

sub ApplyRecalibration_INDEL {
    my $recalFile  = "$req->{'fastq_dir'}$req->{'ugp_id'}_indel_recal";
    my $tranchFile = "$req->{'fastq_dir'}$req->{'ugp_id'}_indel_tranches";
    my $input      = "$req->{'fastq_dir'}$req->{'ugp_id'}_raw_indel.vcf";
    ( my $output = $input ) =~ s/_raw_indel.vcf/_applyed_filtered_INDEL.vcf/;
    my $opts = options( 'ApplyRecalibration_INDEL', '--' ) || '';

    system("touch $output");

    my $cmd =
	"java -Xmx$req->{'gatk_pr_Xmx'}g -jar -Djava.io.tmpdir=$req->{'java_tmp'} "
      . "$soft->{'gatk'}GenomeAnalysisTK.jar -T ApplyRecalibration -R $req->{'fasta'} -input $input "
      . "$opts -recalFile  $recalFile -tranchesFile $tranchFile -mode INDEL -o $output &>> ApplyRecalibration_INDEL.report";

    return $cmd;
}

#-------------------------------------------------------------------------------

sub VariantPrepare {

    file_verify('reduced_bam.list');
    my $opened = open_list('reduced_bam.list');

    # collect column names
    my $sn;
    foreach my $bam ( @{$opened} ) {
        chomp $bam;
        my @path = split( "\/", $bam );
        my @f_name = name_parse( $path[-1] );
        $sn .= "-sn $f_name[0] ";
    }

    # Input and output and options
    my $snp_variant =
      "$req->{'fastq_dir'}$req->{'ugp_id'}_applyed_filtered_SNP.vcf";
    my $indel_variant =
      "$req->{'fastq_dir'}$req->{'ugp_id'}_applyed_filtered_INDEL.vcf";
    my $final_variant = "$req->{'fastq_dir'}$req->{'ugp_id'}_FINAL.vcf";

    ( my $output_snp = $snp_variant ) =~
      s/_applyed_filtered_SNP.vcf/_applyed_filtered_SNP_subset.vcf/;
    ( my $output_indel = $indel_variant ) =~
      s/_applyed_filtered_INDEL.vcf/_applyed_filtered_INDEL_subset.vcf/;

    my $snp_opts   = options( 'SelectVariants_SNP',   '--' ) || '';
    my $indel_opts = options( 'SelectVariants_INDEL', '--' ) || '';
    my $final_opts = options( 'CombineVariants',      '--' ) || '';

    start_log('SelectVariants_SNP');
    my $svs_cmd =
	"java -Xmx$req->{'gatk_pr_Xmx'}g -jar -Djava.io.tmpdir=$req->{'java_tmp'} "
      . "$soft->{'gatk'}GenomeAnalysisTK.jar -T SelectVariants -R $req->{'fasta'} $snp_opts "
      . "$sn --variant $snp_variant -o $output_snp &> SelectVariants_SNP.report";

    cmd_log($svs_cmd);
    runner($svs_cmd);
    end_log('SelectVariants_SNP');

    start_log('SelectVariants_INDEL');
    my $svi_cmd =
	"java -Xmx$req->{'gatk_pr_Xmx'}g -jar -Djava.io.tmpdir=$req->{'java_tmp'} "
      . "$soft->{'gatk'}GenomeAnalysisTK.jar -T SelectVariants -R $req->{'fasta'} $indel_opts "
      . "$sn --variant $indel_variant -o $output_indel &> SelectVariants_INDEL.report";

    cmd_log($svi_cmd);
    runner($svi_cmd);
    end_log('SelectVariants_INDEL');

    start_log('CombineVariants');
    my $cv_cmd =
	"java -Xmx$req->{'gatk_pr_Xmx'}g -jar -Djava.io.tmpdir=$req->{'java_tmp'} "
      . "$soft->{'gatk'}GenomeAnalysisTK.jar -T CombineVariants -R $req->{'fasta'} $final_opts "
      . "--variant $output_snp --variant $output_indel -o $final_variant &> CombineVariants.report";

    cmd_log($cv_cmd);
    runner($cv_cmd);
    end_log('CombineVariants');
}

#-------------------------------------------------------------------------------

$CMDLOG->close;
close STDERR;

