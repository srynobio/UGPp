#!/usr/bin/perl
# FileRevise
use strict;
use warnings;
use IO::Dir;
use Getopt::Long;

#### need to make changes to how the exome data files are made two different lane
#### they should not be!!

my $usage = "

Synopsis:

	FileRevise --reads_dir /path/to/Fastq/Files --pair_only --complete --unchange

Description:

	cApTUrE requires Illumina Fastq naming scheme in order to keep track of files
	and groups of files based on individual lanes and|or read pairs.  
	
	FileRevise will attempt to rename file to the required scheme. 
	FileRevise requires two passes.  The first will show you the changes to your
	files that will be made, the second requires the --complete option
	to be added, to move the file to the new name.

	** Given the wide array of different file names use FileRevise may not always work **

Required options:
	
	--reads_dir|d : The path to your fastq directory.
	
	--pair_only|p : Flag to specify data is pair-end data
			(lane information not specified).
			eg: 9958X1_1.fastq.gz --> 9958X1_XXXX_L001_R1_001.fastq.gz
			eg: 9958X2_130327_700179R_0404_BD1YNUACXX_7_1.txt.gz --> 9958X2_XXXX_L001_R1_001.fastq.gz
	or 
	
	--mult-lane|m : Flag to specify data has lane notation (pair-end inferred).
		        This option is useful to check|modify known lane data.
	
Options:
	--complete|c  : Flag to tell FileRevise to make PERMANENT changes to your fastq files i.e. mv file.
	
	--unchange|u  : Flag to keep original files unchanged i.e. copy file.

	--help|h      : Display this usage statement.

\n";

my ( $cp, $rd, $uc, $po, $ml, $help );
GetOptions(
    "complete|c"    => \$cp,
    "unchange|u"    => \$uc,
    "reads_dir|d=s" => \$rd,
    "pair_only|p"   => \$po,
    "mult_lane|m"   => \$ml,
    "help|h"        => \$help,
);

if ( !$rd or $help ) { die "$usage" }

my $DIR = IO::Dir->new($rd) or die "Path to Fastq.gz files needed.\n";
my $path = $rd;

unless ( $path =~ /\/$/ ) {
    $path =~ s/$/\//;
}

my %groups;
my $fastq_ct = 0;
foreach my $fq ( $DIR->read ) {
    chomp $fq;
    next unless ( $fq =~ /(fastq.gz|fq.gz|txt.gz)$/ );
    my @parts = split /\_/, $fq;
    $fastq_ct++;

    push @{ $groups{ $parts[0] } }, $fq;
}
$DIR->close;

( $fastq_ct > 0 )
  ? warn "Fastq.gz files found.\n\n"
  : die "ERROR: no *fastq.gz or *fq.gz files found\n";

print "Original -> New version\n";
foreach my $reads ( keys %groups ) {
    chomp $reads;

    foreach my $file ( @{ $groups{$reads} } ) {

        my @parts = split /\_/, $file;
        my $check = test_schema( \@parts ) if ( scalar @parts == '5' );

        ( my $lane = $parts[-1] ) =~ s/(\d)\.(fastq.gz|fq.gz|txt.gz)/$1/;

        my $new_version;
        if ($po) {
            $new_version =
              "$parts[0]" . "_XXXX" . "_L001" . "_R$lane" . "_00$lane.fastq.gz";

            print "$file --> $new_version\n";
            system("mv $path$file $path$new_version") if ( $cp and !$uc );
            system("cp $path$file $path$new_version") if ( $cp and $uc );
        }
        elsif ($ml) {

        }
    }
}
print "\nPlease review and if new version looks correct run again with the complete "
      . "option added!\n\n" unless $cp;

print "Name change complete\n\n" if $cp;

##------------------------------------------------------------------------------

sub test_schema {
    my $parts = shift;

    my $file = join( '_', @$parts );
    if ( $parts->[2] =~ /^L/ and $parts->[3] =~ /^R/ ) {
        warn "Lane and read information found "
          . "for fastq file $file no changes to make\n";
        return \$file;
    }
}

##------------------------------------------------------------------------------

