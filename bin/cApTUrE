#!/usr/bin/perl
# cApTUrE: vAriant collecTing UGP pipelinE
use strict;
use warnings;
use IO::File;
use IO::Dir;
use FindBin;
use lib "$FindBin::Bin/../perl_lib";
use Config::Std;
use IPC::System::Simple qw (run);
use Parallel::ForkManager;
use Getopt::Long;

my $VERSION = '0.0.2';

my $usage = "

Synopsis:

	cApTUrE configure/capture.cfg --mail user\@email.com
	cApTUrE configure/capture.cfg -m user\@email.com -rr 4
	cApTUrE --clean 

Description:
	
	cApTUrE:  vAriant collecTing UGP pipeline version: $VERSION

	cApTUrE is a lightweight pipeline written in Perl, created for the
	Utah Genome Project (UGP) http://weatherby.genetics.utah.edu/UGP/wiki/index.php/Main_Page

	Currently it incorporates the following tools:
		-FastQC
		-bwa
		-samtools
		-Picard
		-GATK

	cApTUrE requires a config file given as the first commandline argument.
	And all instruction and requirement are given therein.

Required 
	
	configure/capture.cfg
	
Options:
	--repeat_run|rr   : Setting this option will allow cApTUrE to repeat failed runs
	                    a requested number of times.
			    
	--clean|c   	  : Flag to clean all *list and *report files from bin directory.
	
	--mail|m    	  : cApTUrE will email user sending progress.log, error.log and cmd.log on error or completion.
		      	    Value: user email address.
		      
	--fastqc_skip|fs  : Will skip any FAIL messages fastqc generated.

	--help|h          : Display this usage statement.

\n";

my ( $arc, $clean, $mail, $passfqc, $rr, $help );
GetOptions(
    "repeat_run|rr=i" => \$rr,
    "clean|c"         => \$clean,
    "mail|m=s"        => \$mail,
    "fastqc_skip|fs"  => \$passfqc,
    "help|h"          => \$help,
);
die $usage if $help;

# capture clean
if ($clean) {
    system("rm -f *list *report");
    die "Cleaning up list and report files.\n";
}

my $conf_file = $ARGV[0] or die $usage;

# tracker for repeted_runs
my $times = '0';

# read the config file.
read_config $conf_file => my %config;

## file variables
my $req    = $config{'required'};
my $soft   = $config{'software'};
my $CMDLOG = IO::File->new( $req->{'command_log'}, 'a+' );

# pipeline progress report
my %progress_list =
  map { $_ => 'incomplete' } @{ $config{'order'}{'command_order'} };

# parallel process manager
my $pm = Parallel::ForkManager->new( $req->{'cpu'} );

run_cApTUre();

#-------------------------------------------------------------------------------
#                                   SUBS
#-------------------------------------------------------------------------------

sub run_cApTUre {
    my $PROG_FILE = IO::File->new( 'progress.log', 'a+' );

    # check for position in pipline
    if ( -e 'progress.log' and -s 'progress.log' ) {
        my @progress = `cat progress.log`;
        foreach my $complete (@progress) {
            chomp $complete;
            my ( $sub, $step ) = split /\:/, $complete;
            if ( $step eq 'complete' ) {
                $progress_list{$sub} = 'complete';
            }
        }
    }

    # dispatch table
    my $steps = {
        fastqc                    => \&fastqc,
        indexer                   => \&indexer,
        bwa_mem                   => \&bwa_mem,
        bwa_aln                   => \&bwa_aln,
        bwa_sampe                 => \&bwa_sampe,
        SortSam                   => \&SortSam,
        idxstats                  => \&idxstats,
        flagstat                  => \&flagstat,
        MergeSamFiles             => \&MergeSamFiles,
        MarkDuplicates            => \&MarkDuplicates,
        RealignerTargetCreator    => \&RealignerTargetCreator,
        IndelRealigner            => \&IndelRealigner,
        BaseRecalibrator          => \&BaseRecalibrator,
        PrintReads                => \&PrintReads,
        CollectMultipleMetrics    => \&CollectMultipleMetrics,
        LeftAlignIndels           => \&LeftAlignIndels,
        ReduceReads               => \&ReduceReads,
        UnifiedGenotyper_SNP      => \&UnifiedGenotyper_SNP,
        UnifiedGenotyper_INDEL    => \&UnifiedGenotyper_INDEL,
        VariantRecalibrator_SNP   => \&VariantRecalibrator_SNP,
        VariantRecalibrator_INDEL => \&VariantRecalibrator_INDEL,
        ApplyRecalibration_SNP    => \&ApplyRecalibration_SNP,
        ApplyRecalibration_INDEL  => \&ApplyRecalibration_INDEL,
        VariantPrepare            => \&VariantPrepare,
        mail_user                 => \&mail_user("finished"),
    };

    print $CMDLOG "#############################################\n"
      . "cApTUrE run version $VERSION started on "
      . timestamp() . "\n"
      . "#############################################\n";

    # Run verify and each step of order list
    config_verify();
    foreach my $tool ( @{ $config{'order'}{'command_order'} } ) {
        next if ( $progress_list{$tool} eq 'complete' );
        $steps->{$tool}->();

        $progress_list{$tool} = 'complete';
        print $PROG_FILE "$tool:complete\n";
    }
    $PROG_FILE->close;
}

#-------------------------------------------------------------------------------

sub indexer {

    # dispatch table
    my $indexers = {
        bwa  => \&_bwa_index,
        gatk => \&_gatk_indexer,
    };

    # call each indexer
    foreach my $i ( keys %{$indexers} ) {
        $pm->start and next;
        $indexers->{$i}->();
        $pm->finish;
    }
    $pm->wait_all_children;
}

#-------------------------------------------------------------------------------

sub open_dir {
    my $dir = shift;
    my $DH  = IO::Dir->new($dir)
      or die_messenger("Could not open directory $dir.");
    return \$DH;
}

#-------------------------------------------------------------------------------

sub open_list {
    my $file = shift;

    my @list = `cat $file`;
    return \@list;
}

#-------------------------------------------------------------------------------

sub config_verify {

    # Check versions
    if ( $VERSION ne $req->{'ugp_version'} ) {
        die_messenger( "Software version: $VERSION and requested version: "
              . "$req->{'ugp_version'} do not match." );
    }

    # check that fastq dir hash trailing slash
    # as well as software paths.
    unless ( $req->{'fastq_dir'} =~ /\/$/ ) {
        $req->{'fastq_dir'} =~ s/$/\//;
    }

    foreach my $prog ( keys %{$soft} ) {
        unless ( $soft->{$prog} =~ /\/$/ ) {
            $soft->{$prog} =~ s/$/\//;
        }
    }

    # Check file naming.
    my $DIR = open_dir( $req->{'fastq_dir'} );

    # check file format and file presence.
    my $file_count = 0;
    foreach my $file ( $$DIR->read ) {
        next unless ( $file =~ /(fastq.gz|fq.gz)$/ );
        $file_count++;

        my @fq_file = split /\_/, $file;

        if ( scalar @fq_file != 5 ) {
            die_messenger("Naming conventions incorrect, cApTUre uses Illumina file naming conventions");
        }
    }
    if ( $file_count < 1 ) {
        die_messenger(
                "No fastq.gz files could be found in $req->{'fastq_dir'}: "
              . "please confirm files end in \.fastq.gz, "
              . "check config file path or run FileRevise\n." );
    }
    $$DIR->close;

    # check for reference fasta.
    if ( !-e $req->{'fasta'} ) {
        die_messenger("Fasta file not found");
    }

    unless ( $config{'required'}{'known_indel'} ) {
        die_messenger(
            "Cant find known_indel file[s] for RealignerTargetCreator.");
    }

    if ( $req->{'unified_bg_bams'} ) {
        my $BKB = IO::File->new( 'background_bam.list', 'w' );
        my $bams = `find $req->{'unified_bg_bams'} -name "*reduced.bam"`;
        ($bams)
          ? print $BKB $bams
          : die_messenger("Cant find unified_bg_bams reduced bam file[s]");
        $BKB->close;
    }
}

#-------------------------------------------------------------------------------

sub file_verify {
    my @files = @_;

    my @file_list;
    foreach my $list (@files) {
        unless ( -e $list and -s $list ) {
            die_messenger("Can't find required $list file ");
        }
    }
}

#-------------------------------------------------------------------------------

sub die_messenger {
    my $message = shift;

    open( STDERR, ">>", 'Fatal_error.log' );

    print "Error occured $message\n";
    my $error = "FATAL: $message --";
    die $error;
}

#-------------------------------------------------------------------------------

sub timestamp {
    my $time = localtime;
    return $time;
}

#-------------------------------------------------------------------------------

sub start_log {
    my $program = shift;
    printf $CMDLOG "{cApTUrE} %s started %s: \n", $program, timestamp();
}

#-------------------------------------------------------------------------------

sub end_log {
    my $program = shift;
    printf $CMDLOG "{cApTUrE} %s finished %s: \n", $program, timestamp();
}

#-------------------------------------------------------------------------------

sub cmd_log {
    my $cmd = shift;
    printf $CMDLOG "{cApTUrE} {COMMAND} --> %s: \n", $cmd;
}

#-------------------------------------------------------------------------------

sub options {
    my ( $call, $flag ) = @_;
    my $section = $config{$call};

    my $opts;
    foreach my $options ( keys %{$section} ) {
        next unless ( $section->{$options} );
        if ( $section->{$options} eq 'TRUE' ) {
            $opts .= "$flag$options ";
        }
        elsif ( ref $section->{$options} eq 'ARRAY' ) {
            foreach my $known ( @{ $section->{$options} } ) {
                $opts .= "$flag$options $known ";
            }
        }
        elsif ( $section->{$options} ) {
            $opts .= "$flag$options $section->{$options} ";
        }
    }
    return $opts;
}

#-------------------------------------------------------------------------------

sub name_parse {
    my $path = shift;

    my @schema = split /\_/, $path;
    return @schema;
}

#-------------------------------------------------------------------------------

sub mail_user {
    my ( $message, $reason ) = @_;
    $reason ||= 'cApTUrE';

    if ($mail) {
        system("mail -s \"$message: $reason\" $mail < Fatal_error.log");
        system("mail -s \"$message: $reason\" $mail < cmd.log");
        system("mail -s \"$message: $reason\" $mail < progress.log");
    }
}

#-------------------------------------------------------------------------------

sub runner {
    my $cmd = shift;
    $times++;

    eval { run($cmd) };
    if ($@) {
        run_cApTUre() if ( $rr and $times <= $rr );
        mail_user( "Error running command $cmd", $@ ) if $mail;
        die_messenger("Error running command: $cmd $@\n.");
    }
    $times = '0';
    return;
}

#-------------------------------------------------------------------------------

###### md5 ######
# still need to add to this sub.

sub md5sum {
    start_log('md5sum');

    my $FQDIR = open_dir( $req->{'fastq_dir'} );

    foreach my $fq ( $$FQDIR->read ) {
        next unless ( $fq =~ /\.(fastq.gz|fq.gz)$/ );

        ( my $md = $fq ) =~ s/\.(fastq.gz|fq.gz)$/\.md5/;
        my $cmd = "md5sum $fq > $md";
        cmd_log($cmd);
        runner($cmd);
    }
    $$FQDIR->close;

    # Now collect the md5 files.
    my $MDDIR = open_dir( $req->{'md5'} );

    foreach my $md5 ( $MDDIR->read ) {
        next unless ( $md5 =~ /\.md5$/ );
        ### check to file to each other useing diff.
    }

    end_log('md5sum');
}

#-------------------------------------------------------------------------------

###### fastqc ######

sub fastqc {
    my $opts = options( 'fastqc', '--' ) || '';
    my $FQDIR = open_dir( $req->{'fastq_dir'} );

    # make a fastq directory
    my $output_dir = "$req->{'fastq_dir'}fastqc";
    `mkdir $output_dir`;

    # made this because fastqc craps out after certain amount
    # of parallel runs,
    my $pmfq = Parallel::ForkManager->new('10');

    start_log('fastqc');
    foreach my $file ( $$FQDIR->read ) {
        next unless ( $file =~ /(fastq(.gz)?|fq(.gz)?)$/ );

        $pmfq->start and next;

        my $input = "$req->{'fastq_dir'}$file";
        my $output;
        if ( $file =~ /\.gz/ ) {
            ( $output = $input ) =~ s/.gz$//;
        }
        else { $output = $input; }

        #fastqc needs files to be unzipped.
        unless ( -e $output ) {
            `gunzip -c $input > $output`;
        }

        my @p_file = name_parse($file);

        my $cmd = "$soft->{'fastqc'}fastqc $opts -o $output_dir -f fastq $output 2>> fastQC.report";
        cmd_log($cmd);
        runner($cmd);

        $pmfq->finish;
    }
    $pmfq->wait_all_children;
    end_log('fastqc');

    $$FQDIR->close;

    fastq_reviewer() unless $passfqc;
}

#-------------------------------------------------------------------------------

sub fastq_reviewer {
    my @summaries = `find $req->{'fastq_dir'} -name "summary.txt"`;
    die_messenger("Can't fine fastqc summary.txt files.")
      if scalar @summaries < 1;

    my $fail = 0;
    foreach my $report (@summaries) {
        my @results = `cat $report`;

        foreach my $i (@results) {
            if ( $i =~ /^FAIL/ ) {
                $fail++;
            }
        }
    }
    ( $fail > 0 and !$passfqc )
      ? die_messenger("one or more fastqc tests failed")
      : return;
}

#-------------------------------------------------------------------------------

###### BWA ######

sub _bwa_index {
    start_log('bwa_index');

    my $opts = options( 'bwa_index', '-' ) || '';

    my $cmd =
      "$soft->{'bwa'}bwa index $opts $req->{'fasta'} 2>> bwa_index.report";
    cmd_log($cmd);
    runner($cmd);
    end_log('bwa_index');
}

#-------------------------------------------------------------------------------

sub bwa_mem {
    my $opts = options( 'bwa_mem', '-' ) || '';
    my $FQDIR = open_dir( $req->{'fastq_dir'} );

    my @fq;
    foreach my $file ( $$FQDIR->read ) {
        next unless ( $file =~ /(fq.gz|fastq.gz)$/ );
        push @fq, $file;
    }
    my @sort_fq = sort { $a cmp $b } @fq;

    my $id = '1';
    my @mem_cmd;
    while (@sort_fq) {
        my @sq = splice( @sort_fq, 0, 2 );

        # update with path information.
        my @sfq      = map { "$req->{'fastq_dir'}$_" } @sq;
        my @p_file   = name_parse( $sq[0] );
        my $bam_file = "$req->{'fastq_dir'}$p_file[0]_$p_file[2].bam";
        my $r_group  = '\'@RG'
          . "\\tID:$id\\tSM:$p_file[0]\\tPL:ILLUMINA\\tLB:$p_file[0]-$id\'";
        my $reads = join( " ", @sfq );

        my $cmd =
            "$soft->{'bwa'}bwa mem -M -R $r_group $opts $req->{'fasta'} "
          . "$reads 2>> bwa_mem.report | $soft->{'samtools'}samtools view "
          . "-bSho $bam_file - 2>> samtools_bam.report";

        push @mem_cmd, $cmd;
        $id++;
    }

    # run each command on a separate process.
    start_log('bwa_mem');
    foreach my $command (@mem_cmd) {
        $pm->start and next;
        cmd_log($command);
        runner($command);
        $pm->finish;
    }
    $pm->wait_all_children;
    end_log('bwa_mem');

    $$FQDIR->close;
}

#-------------------------------------------------------------------------------

sub bwa_aln {
    my $opts = options( 'bwa_aln', '-' ) || '';
    my $FQDIR = open_dir( $req->{'fastq_dir'} );

    start_log('bwa_aln');
    foreach my $file ( $$FQDIR->read ) {
        next unless ( $file =~ /\.(fastq.gz|fq.gz)$/ );
        $pm->start and next;

        my @p_file = name_parse($file);

        my $output = "$req->{'fastq_dir'}$p_file[0]_$p_file[2]_$p_file[3].sai";
        my $cmd    = "$soft->{'bwa'}bwa aln $opts $req->{'fasta'} "
          . "$req->{'fastq_dir'}$file > $output 2>> bwa_aln.report";

        cmd_log($cmd);
        runner($cmd);
        $pm->finish;
    }
    $pm->wait_all_children;
    end_log('bwa_aln');

    $$FQDIR->close;
}

#-------------------------------------------------------------------------------

sub bwa_sampe {
    my $opts = options( 'bwa_sampe', '-' ) || '';
    my $DH = open_dir( $req->{'fastq_dir'} );

    my ( @sai, @fq );
    foreach my $file ( $$DH->read ) {
        next unless ( $file =~ /(fq.gz|fastq.gz|sai)$/ );
        if ( $file =~ /sai$/ ) {
            push @sai, $file;
        }
        elsif ( $file =~ /(fastq.gz|fa.gz)$/ ) {
            push @fq, $file;
        }
    }
    my @sort_fq  = sort { $a cmp $b } @fq;
    my @sort_sai = sort { $a cmp $b } @sai;

    # check that the sai files are even.
    if ( scalar @sort_sai % 2 ) {
        die_messenger(
            "sai file look inconsistent, must only have two per fastq file.");
    }

    my @sampe_cmd;
    my $id = '1';
    while (@sort_fq) {

        my @sq = splice( @sort_fq,  0, 2 );
        my @ss = splice( @sort_sai, 0, 2 );

        # update with path information.
        my @sa  = map { "$req->{'fastq_dir'}$_" } @ss;
        my @sfq = map { "$req->{'fastq_dir'}$_" } @sq;

        my @p_file   = name_parse( $ss[0] );
        my $bam_file = "$req->{'fastq_dir'}$p_file[0]_$p_file[1].bam";

        # Specify the read group in a format like Ô@RG\tID:foo\tSM:barÕ
        my $r_group = '\'@RG'
          . "\\tID:$p_file[0]-$id\\tSM:$p_file[0]\\tPL:ILLUMINA\\tLB:$p_file[0]-$id\'";

        my $cmd = "$soft->{'bwa'}bwa sampe -r $r_group $opts $req->{'fasta'} $sa[0] $sa[1] "
                  . "$sfq[0] $sfq[1] | $soft->{'samtools'}samtools view -bSho $bam_file - &>> bwa_sampe.report";

        push @sampe_cmd, $cmd;
        $id++;
    }

    # run each command on a separate process.
    start_log('bwa_sampe');
    foreach my $command (@sampe_cmd) {
        $pm->start and next;
        cmd_log($command);
        runner($command);
        $pm->finish;
    }
    $pm->wait_all_children;
    end_log('bwa_sampe');

    $$DH->close;
}

#-------------------------------------------------------------------------------

###### Picard and Samtools ######

sub SortSam {
    my $DIR = open_dir( $req->{'fastq_dir'} );
    my $SORTLIST = IO::File->new( 'sorted_bam.list', 'w' );

    # get and order
    my $opts = options( 'SortSam', '=' ) || '';
    $opts =~ s/\=(\S+) /$1=/g;

    start_log("SortSam");
    foreach my $bam ( $$DIR->read ) {
        next unless ( $bam =~ /\.bam$/ );
        next if ( $bam =~ /\_sorted.bam/ );

        $pm->start and next;

        # fasta dir
        my $dir = $req->{'fastq_dir'};
        ( my $sort_file = $bam ) =~ s/\.bam$/\_sorted.bam/;

        my $sort_cmd =
            "java -jar -XX:ParallelGCThreads=$req->{'picard_java_threads'} "
          . "-Xmx$req->{'picard_java_Xmx'}g -Djava.io.tmpdir=$req->{'java_tmp'} "
          . "$soft->{'picard'}SortSam.jar INPUT=$dir$bam OUTPUT=$dir$sort_file "
          . "$opts &>> SortSam.report";

        cmd_log($sort_cmd);
        runner($sort_cmd);

        ##push @index_list, $idx_cmd;
        print $SORTLIST "$dir$sort_file\n";
        $pm->finish;
    }
    $pm->wait_all_children;
    end_log("SortSam");

    $$DIR->close;
    $SORTLIST->close;
}

### add stats reviewer.

#-------------------------------------------------------------------------------

sub idxstats {
    my $DIR = open_dir( $req->{'fastq_dir'} );

    start_log("idxstats");
    foreach my $bam ( $$DIR->read ) {
        next unless ( $bam =~ /\_sorted.bam/ );
        ( my $idx_file = $bam ) =~ s/\.bam/\.stats/;

        $pm->start and next;
        my $idx_cmd = "$soft->{'samtools'}samtools idxstats $req->{'fastq_dir'}$bam > $req->{'fastq_dir'}$idx_file 2>> idxstats.report";
        cmd_log($idx_cmd);
        runner($idx_cmd);

        $pm->finish;
    }
    $pm->wait_all_children;
    end_log("SortSam");

    $DIR->close;
}

#-------------------------------------------------------------------------------

sub flagstat {
    my $DIR = open_dir( $req->{'fastq_dir'} );

    start_log("flagstat");
    foreach my $bam ( $$DIR->read ) {
        next unless ( $bam =~ /\_sorted.bam$/ );

        $pm->start and next;

        my $dir = $req->{'fastq_dir'};
        ( my $flag_file = $bam ) =~ s/\.bam/.flagstat/;

        my $cmd = "$soft->{'samtools'}samtools flagstat $dir$bam > $dir$flag_file 2>> flagstat.report";
        cmd_log($cmd);
        runner($cmd);

        $pm->finish;
    }
    $pm->wait_all_children;
    end_log("flagstat");
    $$DIR->close;
}

### add flagstat reviewer

#-------------------------------------------------------------------------------

###### Picard ######

sub _BuildBamIndex {
    my $file = shift;

    start_log('BuildBamIndex');
    my $cmd = "java -Xmx$req->{'picard_java_Xmx'}g -XX:ParallelGCThreads=$req->{'picard_java_threads'} "
              . "-Djava.io.tmpdir=$req->{'java_tmp'} -jar "
              . "$soft->{'picard'}BuildBamIndex.jar INPUT=$file &>> BamIndex.report";

    cmd_log($cmd);
    runner("$cmd");
    end_log('BuildBamIndex');
}

#-------------------------------------------------------------------------------

sub MarkDuplicates {
    my $DDLIST = IO::File->new( 'dedup_bam.list', 'w' );

    # created this section because if working with just pairs MergeSamFile
    # could be unused, although it will not fail.
    my $list_file;
    ( -e 'merged_bam.list' and -s 'merged_bam.list' ) ? $list_file =
      'merged_bam.list'
      : ( -e 'sorted_bam.list' and -s 'sorted_bam.list' ) ? $list_file =
      'sorted_bam.list'
      : die_messenger("sorted_bam.list or merged_bam.list not found.");

    my $opened = open_list($list_file);

    my $opts = options( 'MarkDuplicates', '=' ) || '';
    $opts =~ s/\=(\S+) /$1=/g;

    my %dedup;
    start_log('MarkDuplicates');
    foreach my $bam ( @{$opened} ) {
        chomp $bam;

        ( my $output = $bam ) =~ s/\.bam/_Dedup.bam/;
        ( my $metric = $bam ) =~ s/\.bam/_Dedup.metrics/;

        # create a new merge file of dedups.
        $dedup{$output} = '1';

        $pm->start and next;
        my $cmd = "java -Xmx$req->{'picard_java_Xmx'}g -XX:ParallelGCThreads=$req->{'picard_java_threads'} "
                  . "-Djava.io.tmpdir=$req->{'java_tmp'} -jar "
                  . "$soft->{'picard'}MarkDuplicates.jar INPUT=$bam OUTPUT=$output METRICS_FILE=$metric "
                  . "$opts &>> MarkDuplicates.report";

        cmd_log($cmd);
        runner($cmd);
        $pm->finish;
    }
    $pm->wait_all_children;
    end_log('MarkDuplicates');

    # print the dedup_bam.list file.
    map { print $DDLIST "$_\n" } keys %dedup;

    $DDLIST->close;
}

#-------------------------------------------------------------------------------

sub MergeSamFiles {

    # files will always have to be sorted, to use this function.
    file_verify('sorted_bam.list');
    my $opened = open_list('sorted_bam.list');

    my $BAMLIST = IO::File->new( 'merged_bam.list', 'a+' );

    # get and order
    my $opts = options( 'MergeSamFiles', '=' ) || '';
    $opts =~ s/\=(\S+) /$1=/g;

    my %merge;
    foreach my $file ( @{$opened} ) {
        chomp $file;
        $file =~ s/$req->{'fastq_dir'}//;
        my @p_file = name_parse($file);

        # p_file[0] is the individual
        push @{ $merge{ $p_file[0] } }, $file;
    }

  # Will return if were trying to merge single files, which we don't need to do.
    my $single;
    my @sam_list = map { @{ $merge{$_} } } keys %merge;
    if ( scalar @sam_list == scalar keys %merge ) {
        $single = 'yes';
    }
    if ($single) { return }

    my %merge_list;
    start_log('MergeSamFiles');
    foreach my $bam ( keys %merge ) {
        my $input = join( ':', @{ $merge{$bam} } );

        # add the paths and input/output tags
        $input =~ s/^/INPUT=$req->{'fastq_dir'}/;
        $input =~ s/:/ INPUT=$req->{'fastq_dir'}/g;
        my $output = "OUTPUT=$req->{'fastq_dir'}$bam" . "_merged.bam";

        # This is what creates the merged_bam.list hash for the religners
        my $merge_bam = "$req->{'fastq_dir'}$bam" . "_merged.bam";
        $merge_list{$merge_bam} = '1';

        # run each command in parallel job.
        $pm->start and next;
        my $cmd = "java -Xmx$req->{'picard_java_Xmx'}g -XX:ParallelGCThreads=$req->{'picard_java_threads'} "
                  . "-Djava.io.tmpdir=$req->{'java_tmp'} -jar "
                  . "$soft->{'picard'}MergeSamFiles.jar $opts $input $output 2>> MergeSamFiles.report";

        cmd_log($cmd);
        runner($cmd);
        $pm->finish;
    }
    $pm->wait_all_children;
    end_log('MergeSamFiles');

    # print the merge_bam_list file.
    map { print $BAMLIST "$_\n"; } keys %merge_list;

    $BAMLIST->close;
}

#-------------------------------------------------------------------------------

sub CollectMultipleMetrics {
    my $opts = options( 'CollectMultipleMetrics', '=' ) || '';
    $opts =~ s/\=(\S+) /$1=/g;

    file_verify('recal_bam.list');
    my $opened = open_list('recal_bam.list');

    start_log('CollectMultipleMetrics');
    foreach my $bam ( @{$opened} ) {
        chomp $bam;

        $pm->start and next;
        ( my $w_file = $bam ) =~ s/\.bam$/\.metrics/;

        my $cmd = "java -Xmx$req->{'picard_java_Xmx'}g -XX:ParallelGCThreads=$req->{'picard_java_threads'} "
                  . "-Djava.io.tmpdir=$req->{'java_tmp'} -jar "
                  . "$soft->{'picard'}CollectMultipleMetrics.jar INPUT=$bam $opts "
                  . "REFERENCE_SEQUENCE=$req->{'fasta'} OUTPUT=$w_file 2>> CollectMultipleMetrics.report";

        cmd_log("$cmd");
        runner("$cmd");
        $pm->finish;
    }
    $pm->wait_all_children;
    end_log('CollectMultipleMetrics');
}

#-------------------------------------------------------------------------------

###### GATK ######

sub _gatk_indexer {

    # gatk required use, but is a picard tool
    my $picard = "$soft->{'picard'}CreateSequenceDictionary.jar";
    my $fasta  = "$req->{'fasta'}";
    my $output = "$req->{'fasta'}";

    start_log('GATK_INDEXING');

    $output =~ s/(.*)\.(fasta|fa)/$1.dict/;
    my $picard_cmd = "java -jar $picard R=$fasta O=$output 2>> seq_dict.report";
    cmd_log($picard_cmd);
    runner("$picard_cmd");

    # now run to prepare the fasta index file.
    my $samtools = "$soft->{'samtools'}samtools faidx";
    my $sam_cmd  = "$samtools $fasta";
    cmd_log($sam_cmd);
    runner("$sam_cmd");

    end_log('GATK_INDEXING');
}

#-------------------------------------------------------------------------------

sub RealignerTargetCreator {
    my @knowns  = @{ $config{'required'}{'known_indel'} };
    my $opts    = options( 'RealignerTargetCreator', '--' ) || '';
    my $outfile = "$req->{'fastq_dir'}$req->{'ugp_id'}_realign.intervals";

    file_verify('dedup_bam.list');

    my $known_vcfs;
    foreach my $vcf (@knowns) {
        chomp $vcf;
        next unless ( $vcf =~ /\.vcf$/ );
        $known_vcfs .= "--known $vcf ";
    }

    start_log("RealignerTargetCreator");
    my $cmd = "java -Xmx$req->{'gatk_tc_Xmx'}g -jar -Djava.io.tmpdir=$req->{'java_tmp'} "
              . "$soft->{'gatk'}GenomeAnalysisTK.jar -T RealignerTargetCreator -R $req->{'fasta'} -I dedup_bam.list $opts "
              . "$known_vcfs -o $outfile &>> RealignerTargetCreator.report";

    cmd_log($cmd);
    runner("$cmd");
    end_log("RealignerTargetCreator");
}

#-------------------------------------------------------------------------------

sub IndelRealigner {
    my $INDEL_LIST = IO::File->new( 'realign_bam.list', 'w' );
    my $opts   = options( 'IndelRealigner', '--' ) || '';
    my $target = "$req->{'fastq_dir'}$req->{'ugp_id'}_realign.intervals";
    my @knowns = @{ $config{'required'}{'known_indel'} };

    my $known_vcfs;
    foreach my $vcf (@knowns) {
        chomp $vcf;
        next unless ( $vcf =~ /\.vcf$/ );
        $known_vcfs .= "--knownAlleles $vcf ";
    }
    file_verify('dedup_bam.list');
    my $opened = open_list('dedup_bam.list');

    my %indel_list;
    start_log('IndelRealigner');
    foreach my $dedup ( @{$opened} ) {
        chomp $dedup;

        next unless ( $dedup =~ /\.bam$/ );
        ( my $output = $dedup ) =~ s/\.bam/_realign.bam/;

        $indel_list{$output} = '1';

        $pm->start and next;
        my $cmd = "java -Xmx$req->{'gatk_ir_Xmx'}g -jar -XX:ParallelGCThreads=$req->{'picard_java_threads'} "
                  . "-Djava.io.tmpdir=$req->{'java_tmp'} $soft->{'gatk'}GenomeAnalysisTK.jar -T IndelRealigner -R $req->{'fasta'} "
                  . " -I $dedup $opts -targetIntervals $target $known_vcfs -o $output &>> IndelRealigner.report";

        cmd_log($cmd);
        runner($cmd);
        $pm->finish;
    }
    $pm->wait_all_children;
    end_log('IndelRealigner');

    # create the list file.
    map { print $INDEL_LIST "$_\n" } keys %indel_list;
    $INDEL_LIST->close;
}

#-------------------------------------------------------------------------------

sub ReduceReads {
    my $opts = options( 'ReduceReads', '--' ) || '';
    my $RD_LIST = IO::File->new( 'reduced_bam.list', 'w' );

    file_verify('recal_bam.list');
    my $opened = open_list('recal_bam.list');

    start_log('ReduceReads');
    my %reduced;
    foreach my $bam ( @{$opened} ) {
        chomp $bam;
        ( my $output = $bam ) =~ s/\.bam$/_reduced.bam/;

        $reduced{$output} = '1';

        $pm->start and next;
        my $cmd = "java -Xmx$req->{'gatk_rr_Xmx'}g -jar -Djava.io.tmpdir=$req->{'java_tmp'} "
                  . "-XX:ParallelGCThreads=$req->{'picard_java_threads'} $soft->{'gatk'}GenomeAnalysisTK.jar "
                  . "-T ReduceReads -R $req->{'fasta'} -I $bam $opts "
                  . "-o $output &>> ReduceReads.report";

        cmd_log($cmd);
        runner("$cmd");
        $pm->finish;
    }
    $pm->wait_all_children;
    end_log("ReduceReads");

    # create the list file.
    map { print $RD_LIST $_, "\n" } keys %reduced;
    $RD_LIST->close;
}

#-------------------------------------------------------------------------------

sub BaseRecalibrator {
    my $opts = options( 'BaseRecalibrator', '--' ) || '';
    my $output = "$req->{'fastq_dir'}$req->{'ugp_id'}_recal_data.table";

    file_verify('realign_bam.list');
    my $opened_bams = open_list('realign_bam.list');

    my @known_lists = @{ $config{'required'}{'known_indel'} };
    my $dbsnp       = $config{'required'}{'known_dbsnp'};
    push @known_lists, $dbsnp;

    my $known_vcfs;
    foreach my $vcf (@known_lists) {
        chomp $vcf;
        next unless ( $vcf =~ /\.vcf$/ );
        $known_vcfs .= "--knownSites $vcf ";
    }

    start_log('BaseRecalibrator');
    foreach my $bam ( @{$opened_bams} ) {
        chomp $bam;

        $pm->start and next;
        my $cmd = "java -Xmx$req->{'gatk_br_Xmx'}g -jar -Djava.io.tmpdir=$req->{'java_tmp'} "
                  . "$soft->{'gatk'}GenomeAnalysisTK.jar -T BaseRecalibrator -R $req->{'fasta'} -I $bam $opts "
                  . "$known_vcfs -o $output &>> BaseRecalibrator.report";

        cmd_log($cmd);
        runner($cmd);
        $pm->finish;
    }
    $pm->wait_all_children;
    end_log('BaseRecalibrator');
}

#-------------------------------------------------------------------------------

sub PrintReads {
    my $opts       = options( 'PrintReads', '--' ) || '';
    my $bqsr       = "$req->{'fastq_dir'}$req->{'ugp_id'}_recal_data.table";
    my $RECAL_LIST = IO::File->new( 'recal_bam.list', 'w' );

    file_verify('realign_bam.list');
    my $opened = open_list('realign_bam.list');

    my %recal;
    start_log('PrintReads');
    foreach my $bam ( @{$opened} ) {
        chomp $bam;

        my ($output) = $bam =~ /(.*)\.bam/;
        $output =~ s/$/_recal.bam/;

        $recal{$output} = 1;

        $pm->start and next;
        my $cmd = "java -Xmx$req->{'gatk_pr_Xmx'}g -jar -Djava.io.tmpdir=$req->{'java_tmp'} "
                  . "$soft->{'gatk'}GenomeAnalysisTK.jar -T PrintReads -R $req->{'fasta'} -I $bam $opts "
                  . "-BQSR $bqsr -o $output &>> PrintReads.report";

        cmd_log($cmd);
        runner($cmd);
        $pm->finish;
    }
    $pm->wait_all_children;
    end_log('PrintReads');

    # create the list file.
    map { print $RECAL_LIST $_, "\n" } keys %recal;
    $RECAL_LIST->close;
}

#-------------------------------------------------------------------------------

sub UnifiedGenotyper_SNP {
    my $opts = options( 'UnifiedGenotyper_SNP', '--' ) || '';
    my $output = "$req->{'fastq_dir'}$req->{'ugp_id'}_raw_snp.vcf";

    file_verify('reduced_bam.list');
    my $opened = open_list('reduced_bam.list');

    my $background;
    if ( $req->{'unified_bg_bams'} ) {
        file_verify('background_bam.list');
        my $bams = open_list('background_bam.list');

        foreach my $backs ( @{$bams} ) {
            chomp $backs;
            $background .= "-I $backs ";
        }
    }

    my $input_bams;
    foreach my $bam ( @{$opened} ) {
        chomp $bam;
        $input_bams .= "-I $bam ";
    }

    start_log('UnifiedGenotyper_SNP');
    my $cmd = "java -Xmx$req->{'gatk_ug_Xmx'}g -jar -Djava.io.tmpdir=$req->{'java_tmp'} "
              . "$soft->{'gatk'}GenomeAnalysisTK.jar -T UnifiedGenotyper -R $req->{'fasta'} $input_bams $background "
              . "$opts -o $output &>> UnifiedGenotyper_SNP.report";

    cmd_log($cmd);
    runner($cmd);
    start_log('UnifiedGenotyper_SNP');
}

#-------------------------------------------------------------------------------

sub UnifiedGenotyper_INDEL {
    my $opts = options( 'UnifiedGenotyper_INDEL', '--' ) || '';
    my $output = "$req->{'fastq_dir'}$req->{'ugp_id'}_raw_indel.vcf";

    file_verify('reduced_bam.list');
    my $opened = open_list('reduced_bam.list');

    my $background;
    if ( $req->{'unified_bg_bams'} ) {
        file_verify('background_bam.list');
        my $bams = open_list('background_bam.list');

        foreach my $backs ( @{$bams} ) {
            chomp $backs;
            $background .= "-I $backs ";
        }
    }

    my $input_bams;
    foreach my $bam ( @{$opened} ) {
        chomp $bam;
        $input_bams .= "-I $bam ";
    }

    start_log('UnifiedGenotyper_INDEL');
    my $cmd = "java -Xmx$req->{'gatk_ug_Xmx'}g -jar -Djava.io.tmpdir=$req->{'java_tmp'} "
              . "$soft->{'gatk'}GenomeAnalysisTK.jar -T UnifiedGenotyper -R $req->{'fasta'} $input_bams $background "
              . "$opts -o $output &>> UnifiedGenotyper_INDEL.report";

    cmd_log($cmd);
    runner($cmd);
    end_log('UnifiedGenotyper_INDEL');
}

#-------------------------------------------------------------------------------

sub VariantRecalibrator_SNP {

    my $input = "$req->{'fastq_dir'}$req->{'ugp_id'}_raw_snp.vcf";

    my @vqsr;
    if ( ref $config{'required'}{'vqsr_snp_vcf'} eq 'ARRAY' ) {
        @vqsr = @{ $config{'required'}{'vqsr_snp_vcf'} };
    }
    else {
        push @vqsr, $config{'required'}{'vqsr_snp_vcf'};
    }

    my @snp_file;
    if ( ref $config{'VariantRecalibrator_SNP'}{'resource'} eq 'ARRAY' ) {
        @snp_file = @{ $config{'VariantRecalibrator_SNP'}{'resource'} };
    }
    else {
        push @snp_file, $config{'VariantRecalibrator_SNP'}{'resource'};
    }

    # shift in order the resource lines.
    my $resource_call;
    if (@vqsr) {
        while ( my $site = @vqsr ) {
            my $resource = shift @snp_file;
            my $file     = shift @vqsr;
            $resource_call .= "--resource:$resource $file ";
        }

        # remove the resource info from the config hash
        delete $config{'VariantRecalibrator_SNP'}{'resource'};
    }

    # now run options to get others
    my $opts = options( 'VariantRecalibrator_SNP', '--' ) || '';

    my $recalFile = "-recalFile $req->{'fastq_dir'}$req->{'ugp_id'}_snp_recal";
    my $tranchFile =
      "-tranchesFile $req->{'fastq_dir'}$req->{'ugp_id'}_snp_tranches";
    my $rscriptFile =
      "-rscriptFile $req->{'fastq_dir'}$req->{'ugp_id'}_snp_plots.R";

    start_log('VariantRecalibrator_SNP');
    my $cmd = "java -Xmx$req->{'gatk_pr_Xmx'}g -jar -Djava.io.tmpdir=$req->{'java_tmp'} "
              . "$soft->{'gatk'}GenomeAnalysisTK.jar -T VariantRecalibrator -R $req->{'fasta'} -input $input $resource_call "
              . "$opts $recalFile $tranchFile $rscriptFile -mode SNP &>> VariantRecalibrator_SNP.report";

    cmd_log($cmd);
    runner($cmd);
    end_log('VariantRecalibrator_SNP');
}

#-------------------------------------------------------------------------------

sub VariantRecalibrator_INDEL {
    my $input = "$req->{'fastq_dir'}$req->{'ugp_id'}_raw_indel.vcf";

    my @vqsr;
    if ( ref $config{'required'}{'vqsr_indel_vcf'} eq 'ARRAY' ) {
        @vqsr = @{ $config{'required'}{'vqsr_indel_vcf'} };
    }
    else {
        push @vqsr, $config{'required'}{'vqsr_indel_vcf'};
    }

    my @indel_file;
    if ( ref $config{'VariantRecalibrator_INDEL'}{'resource'} eq 'ARRAY' ) {
        @indel_file = @{ $config{'VariantRecalibrator_INDEL'}{'resource'} };
    }
    else {
        push @indel_file, $config{'VariantRecalibrator_INDEL'}{'resource'};
    }

    my $resource_call;
    if (@vqsr) {
        while ( my $site = @vqsr ) {
            my $resource = shift @indel_file;
            my $file     = shift @vqsr;
            $resource_call .= "--resource:$resource $file ";
        }

        # remove the resource info from the config hash
        delete $config{'VariantRecalibrator_INDEL'}{'resource'};
    }

    # now run options to get others
    my $opts = options( 'VariantRecalibrator_INDEL', '--' ) || '';

    my $recalFile =
      "-recalFile $req->{'fastq_dir'}$req->{'ugp_id'}_indel_recal";
    my $tranchFile =
      "-tranchesFile $req->{'fastq_dir'}$req->{'ugp_id'}_indel_tranches";
    my $rscriptFile =
      "-rscriptFile $req->{'fastq_dir'}$req->{'ugp_id'}_indel_plots.R";

    start_log('VariantRecalibrator_INDEL');
    my $cmd = "java -Xmx$req->{'gatk_pr_Xmx'}g -jar -Djava.io.tmpdir=$req->{'java_tmp'} "
              . "$soft->{'gatk'}GenomeAnalysisTK.jar -T VariantRecalibrator -R $req->{'fasta'} -input $input $resource_call "
              . "$opts $recalFile $tranchFile $rscriptFile -mode INDEL &>> VariantRecalibrator_INDEL.report";

    cmd_log($cmd);
    runner($cmd);
    end_log('VariantRecalibrator_INDEL');
}

#-------------------------------------------------------------------------------

sub ApplyRecalibration_SNP {
    my $recalFile  = "$req->{'fastq_dir'}$req->{'ugp_id'}_snp_recal";
    my $tranchFile = "$req->{'fastq_dir'}$req->{'ugp_id'}_snp_tranches";
    my $input      = "$req->{'fastq_dir'}$req->{'ugp_id'}_raw_snp.vcf";
    ( my $output = $input ) =~ s/_raw_snp.vcf/_applyed_filtered_SNP.vcf/;
    my $opts = options( 'ApplyRecalibration_SNP', '--' ) || '';

    file_verify( $recalFile, $tranchFile, $input );

    start_log('ApplyRecalibration_SNP');
    my $cmd = "java -Xmx$req->{'gatk_pr_Xmx'}g -jar -Djava.io.tmpdir=$req->{'java_tmp'} "
              . "$soft->{'gatk'}GenomeAnalysisTK.jar -T ApplyRecalibration -R $req->{'fasta'} -input $input "
              . "$opts -recalFile  $recalFile -tranchesFile $tranchFile -mode SNP -o $output &>> ApplyRecalibration_SNP.report";

    cmd_log($cmd);
    runner($cmd);
    end_log('ApplyRecalibration_SNP');
}

#-------------------------------------------------------------------------------

sub ApplyRecalibration_INDEL {
    my $recalFile  = "$req->{'fastq_dir'}$req->{'ugp_id'}_indel_recal";
    my $tranchFile = "$req->{'fastq_dir'}$req->{'ugp_id'}_indel_tranches";
    my $input      = "$req->{'fastq_dir'}$req->{'ugp_id'}_raw_indel.vcf";
    ( my $output = $input ) =~ s/_raw_indel.vcf/_applyed_filtered_INDEL.vcf/;
    my $opts = options( 'ApplyRecalibration_INDEL', '--' ) || '';

    file_verify( $recalFile, $tranchFile, $input );

    start_log('ApplyRecalibration_INDEL');
    my $cmd = "java -Xmx$req->{'gatk_pr_Xmx'}g -jar -Djava.io.tmpdir=$req->{'java_tmp'} "
              . "$soft->{'gatk'}GenomeAnalysisTK.jar -T ApplyRecalibration -R $req->{'fasta'} -input $input "
              . "$opts -recalFile  $recalFile -tranchesFile $tranchFile -mode INDEL -o $output &>> ApplyRecalibration_INDEL.report";

    cmd_log($cmd);
    runner($cmd);
    end_log('ApplyRecalibration_INDEL');
}

#-------------------------------------------------------------------------------

sub VariantPrepare {

    file_verify('reduced_bam.list');
    my $opened = open_list('reduced_bam.list');

    # collect column names
    my $sn;
    foreach my $bam ( @{$opened} ) {
        chomp $bam;
        my @path = split( "\/", $bam );
        my @f_name = name_parse( $path[-1] );
        $sn .= "-sn $f_name[0] ";
    }

    # Input and output and options
    my $snp_variant =
      "$req->{'fastq_dir'}$req->{'ugp_id'}_applyed_filtered_SNP.vcf";
    my $indel_variant =
      "$req->{'fastq_dir'}$req->{'ugp_id'}_applyed_filtered_INDEL.vcf";
    my $final_variant = "$req->{'fastq_dir'}$req->{'ugp_id'}_FINAL.vcf";

    ( my $output_snp = $snp_variant ) =~
      s/_applyed_filtered_SNP.vcf/_applyed_filtered_SNP_subset.vcf/;
    ( my $output_indel = $indel_variant ) =~
      s/_applyed_filtered_INDEL.vcf/_applyed_filtered_INDEL_subset.vcf/;

    my $snp_opts   = options( 'SelectVariants_SNP',   '--' ) || '';
    my $indel_opts = options( 'SelectVariants_INDEL', '--' ) || '';
    my $final_opts = options( 'CombineVariants',      '--' ) || '';

    start_log('SelectVariants_SNP');
    my $svs_cmd = "java -Xmx$req->{'gatk_pr_Xmx'}g -jar -Djava.io.tmpdir=$req->{'java_tmp'} "
                  . "$soft->{'gatk'}GenomeAnalysisTK.jar -T SelectVariants -R $req->{'fasta'} $snp_opts "
                  . "$sn --variant $snp_variant -o $output_snp &> SelectVariants_SNP.report";

    cmd_log($svs_cmd);
    runner($svs_cmd);
    end_log('SelectVariants_SNP');

    start_log('SelectVariants_INDEL');
    my $svi_cmd = "java -Xmx$req->{'gatk_pr_Xmx'}g -jar -Djava.io.tmpdir=$req->{'java_tmp'} "
                  . "$soft->{'gatk'}GenomeAnalysisTK.jar -T SelectVariants -R $req->{'fasta'} $indel_opts "
                  . "$sn --variant $indel_variant -o $output_indel &> SelectVariants_INDEL.report";

    cmd_log($svi_cmd);
    runner($svi_cmd);
    end_log('SelectVariants_INDEL');

    start_log('CombineVariants');
    my $cv_cmd = "java -Xmx$req->{'gatk_pr_Xmx'}g -jar -Djava.io.tmpdir=$req->{'java_tmp'} "
                 . "$soft->{'gatk'}GenomeAnalysisTK.jar -T CombineVariants -R $req->{'fasta'} $final_opts "
                 . "--variant $output_snp --variant $output_indel -o $final_variant &> CombineVariants.report";

    cmd_log($cv_cmd);
    runner($cv_cmd);
    end_log('CombineVariants');
}

#-------------------------------------------------------------------------------

$CMDLOG->close;
close STDERR;

